.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Model 3pm"
.TH Config::Model 3pm "2010-10-19" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Model \- Framework to create configuration validation tools and editors
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& # create new Model object
\& my $model = Config::Model\->new() ;
\&
\& # create config model
\& $model \->create_config_class 
\&  (
\&   name => "SomeRootClass",
\&   element => [ ...  ]
\&  ) ;
\&
\& # create instance 
\& my $instance = $model\->instance (root_class_name => \*(AqSomeRootClass\*(Aq, 
\&                                  instance_name => \*(Aqtest1\*(Aq);
\&
\& # get configuration tree root
\& my $cfg_root = $instance \-> config_root ;
\&
\& # You can also use load on demand
\& my $model = Config::Model\->new() ;
\&
\& # this call will look for a AnotherClass.pl that will contain
\& # the model
\& my $inst2 = $model\->instance (root_class_name => \*(AqAnotherClass\*(Aq, 
\&                              instance_name => \*(Aqtest2\*(Aq);
\&
\& # then get configuration tree root
\& my $cfg_root = $inst2 \-> config_root ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Using Config::Model, a typical configuration validation tool will be
made of 3 parts :
.IP "1." 4
A reader and writer that will parse the configuration file and transform in a tree representation within Config::Model. The values contained in this configuration tree can be written back in the configuraiton file(s).
.IP "2." 4
A validation engine which is in charge of validating the content and
structure of configuration stored in the configuration tree. This
validation engine will follow the structure and constraint declared in
a configuration model. This model is a kind of schema for the
configuration tree.
.IP "3." 4
A user interface to modify the content of the configuration tree. A
modification will be validated instantly by the validation engine.
.SH "Storage backend, configuration reader and writer"
.IX Header "Storage backend, configuration reader and writer"
See Config::Model::AutoRead for details
.SH "Validation engine"
.IX Header "Validation engine"
\&\f(CW\*(C`Config::Model\*(C'\fR provides a way to get a validation engine from a set
of rules. This set of rules is called the configuration model.
.SH "User interface"
.IX Header "User interface"
The user interface will use some parts of the \s-1API\s0 to set and get
configuration values. More importantly, a generic user interface will
need to explore the configuration model to be able to generate at
run-time relevant configuration screens.
.PP
Simple text interface if provided in this module. Curses and Tk
interfaces are provided by Config::Model::CursesUI and
Config::Model::TkUI.
.SH "Constructor"
.IX Header "Constructor"
Simply call new without parameters:
.PP
.Vb 1
\& my $model = Config::Model \-> new ;
.Ve
.PP
This will create an empty shell for your model.
.SH "Configuration Model"
.IX Header "Configuration Model"
To validate a configuration tree, we must create a configuration model
that will set all the properties of the validation engine you want to
create.
.PP
The configuration model is expressed in a declarative form (i.e. a
Perl data structure which is always easier to maintain than a lot of
code)
.PP
Each configuration class contains a set of:
.IP "\(bu" 4
node element that will refer to another configuration class
.IP "\(bu" 4
value element that will contains actual configuration data
.IP "\(bu" 4
List or hash of node or value elements
.PP
By declaring a set of configuration classes and refering them in node
element, you will shape the structure of your configuration tree.
.PP
The structure of the configuration data must be based on a tree
structure. This structure has several advantages:
.IP "\(bu" 4
Unique path to get to a node or a leaf.
.IP "\(bu" 4
Simpler exploration and query
.IP "\(bu" 4
Simple hierarchy. Deletion of configuration items is simpler to grasp:
when you cut a branch, all the leaves attaches to that branch go down.
.PP
But using a tree has also some drawbacks:
.IP "\(bu" 4
A complex configuration cannot be mapped on a simple tree.  Some more
relation between nodes and leaves must be added.
.IP "\(bu" 4
Some configuration part are actually graph instead of a tree (for
instance, any configuration that will map a service to a
resource). The graph relation must be decomposed in a tree with
special \fIreference\fR relation. See \*(L"Value Reference\*(R" in Config::Model::Value
.PP
Note: a configuration tree is a tree of objects. The model is declared
with classes. The classes themselves have relations that closely match
the relation of the object of the configuration tree. But the class
need not to be declared in a tree structure (always better to reuse
classes). But they must be declared as a \s-1DAG\s0 (directed acyclic graph).
.PP
Each configuration class declaration specifies:
.IP "\(bu" 8
The \f(CW\*(C`name\*(C'\fR of the class (mandatory)
.IP "\(bu" 8
A \f(CW\*(C`class_description\*(C'\fR used in user interfaces (optional)
.IP "\(bu" 8
Optional include specification to avoid duplicate declaration of elements.
.IP "\(bu" 8
The class elements
.PP
Each element will specify:
.IP "8" 4
.IX Item "8"
Most importantly, the type of the element (mostly \f(CW\*(C`leaf\*(C'\fR, or \f(CW\*(C`node\*(C'\fR)
.IP "*" 4
The properties of each element (boundaries, check, integer or string,
enum like type ...)
.IP "*" 4
The default values of parameters (if any)
.IP "*" 4
Whether the parameter is mandatory
.IP "*" 4
Targeted audience (beginner, advance, master), i.e. the level of
expertise required to tinker a parameter (to hide expert parameters
from newbie eyes)
.IP "*" 4
On-line help (for each parameter or value of parameter)
.PP
See Config::Model::Node for details on how to declare a
configuration class.
.PP
Example:
.PP
.Vb 10
\& $ cat lib/Config/Model/models/Xorg.pl
\& [
\&   {
\&     name => \*(AqXorg\*(Aq,
\&     class_description => \*(AqTop level Xorg configuration.\*(Aq,
\&     include => [ \*(AqXorg::ConfigDir\*(Aq],
\&     element => [
\&                 Files => {
\&                           type => \*(Aqnode\*(Aq,
\&                           description => \*(AqFile pathnames\*(Aq,
\&                           config_class_name => \*(AqXorg::Files\*(Aq
\&                          },
\&                 # snip
\&                ]
\&   },
\&   {
\&     name => \*(AqXorg::DRI\*(Aq,
\&     element => [
\&                 Mode => {
\&                          type => \*(Aqleaf\*(Aq,
\&                          value_type => \*(Aquniline\*(Aq,
\&                          description => \*(AqDRI mode, usually set to 0666\*(Aq
\&                         }
\&                ]
\&   }
\& ];
.Ve
.SH "Configuration instance"
.IX Header "Configuration instance"
A configuration instance if the staring point of a configuration tree.
When creating a model instance, you must specify the root class name, I.e. the
configuration class that is used by the root node of the tree.
.PP
.Vb 6
\& my $model = Config::Model\->new() ;
\& $model \->create_config_class 
\&  (
\&   name => "SomeRootClass",
\&   element => [ ...  ]
\&  ) ;
\&
\& # instance name is \*(Aqdefault\*(Aq 
\& my $inst = $model\->instance (root_class_name => \*(AqSomeRootClass\*(Aq);
.Ve
.PP
You can create several separated instances from a model using 
\&\f(CW\*(C`name\*(C'\fR option:
.PP
.Vb 3
\& # instance name is \*(Aqdefault\*(Aq 
\& my $inst = $model\->instance (root_class_name => \*(AqSomeRootClass\*(Aq, 
\&                              name            => \*(Aqtest1\*(Aq);
.Ve
.PP
Usually, model files will be loaded automatically depending on
\&\f(CW\*(C`root_class_name\*(C'\fR. But you can choose to specify the file containing
the model with \f(CW\*(C`model_file\*(C'\fR parameter. This is mostly useful for
tests.
.SH "Configuration class"
.IX Header "Configuration class"
A configuration class is made of series of elements which are detailed
in Config::Model::Node.
.PP
Whatever its type (node, leaf,... ), each element of a node has
several other properties:
.IP "experience" 4
.IX Item "experience"
By using the \f(CW\*(C`experience\*(C'\fR parameter, you can change the experience
level of each element. Possible experience levels are \f(CW\*(C`master\*(C'\fR,
\&\f(CW\*(C`advanced\*(C'\fR and \f(CW\*(C`beginner\*(C'\fR (default).
.IP "level" 4
.IX Item "level"
Level is \f(CW\*(C`important\*(C'\fR, \f(CW\*(C`normal\*(C'\fR or \f(CW\*(C`hidden\*(C'\fR.
.Sp
The level is used to set how configuration data is presented to the
user in browsing mode. \f(CW\*(C`Important\*(C'\fR elements will be shown to the user
no matter what. \f(CW\*(C`hidden\*(C'\fR elements will be explained with the \fIwarp\fR
notion.
.IP "status" 4
.IX Item "status"
Status is \f(CW\*(C`obsolete\*(C'\fR, \f(CW\*(C`deprecated\*(C'\fR or \f(CW\*(C`standard\*(C'\fR (default).
.Sp
Using a deprecated element will issue a warning. Using an obsolete
element will raise an exception.
.IP "description" 4
.IX Item "description"
Description of the element. This description will be used when
generating user interfaces.
.IP "summary" 4
.IX Item "summary"
Summary of the element. This description will be used when generating
user interfaces and may be used in comments when writing the
configuration file.
.IP "class_description" 4
.IX Item "class_description"
Description of the configuration class. This description will be used
when generating user interfaces.
.IP "generated_by" 4
.IX Item "generated_by"
Mention with a descriptive string if this class was generated by a
program.  This parameter is currently reserved for
Config::Model::Itself model editor.
.IP "include" 4
.IX Item "include"
Include element description from another class.
.Sp
.Vb 1
\&  include => \*(AqAnotherClass\*(Aq ,
.Ve
.Sp
or
.Sp
.Vb 1
\&  include => [qw/ClassOne ClassTwo/]
.Ve
.Sp
In a configuration class, the order of the element is important. For
instance if \f(CW\*(C`foo\*(C'\fR is warped by \f(CW\*(C`bar\*(C'\fR, you must declare \f(CW\*(C`bar\*(C'\fR
element before \f(CW\*(C`foo\*(C'\fR.
.Sp
When including another class, you may wish to insert the included
elements after a specific element of your including class:
.Sp
.Vb 4
\&  # say AnotherClass contains element xyz
\&  include => \*(AqAnotherClass\*(Aq ,
\&  include_after => "foo" ,
\&  element => [ bar => ... , foo => ... , baz => ... ]
.Ve
.Sp
Now the element of your class will be:
.Sp
.Vb 1
\&  ( bar , foo , xyz , baz )
.Ve
.PP
Example:
.PP
.Vb 1
\&  my $model = Config::Model \-> new ;
\&
\&  $model\->create_config_class 
\&  (
\&   config_class_name => \*(AqSomeRootClass\*(Aq,
\&   experience        => [ [ qw/tree_macro warp/ ] => \*(Aqadvanced\*(Aq] ,
\&   description       => [ X => \*(AqX\-ray\*(Aq ],
\&   level             => [ \*(Aqtree_macro\*(Aq => \*(Aqimportant\*(Aq ] ,
\&   class_description => "SomeRootClass description",
\&   element           => [ ... ] 
\&  ) ;
.Ve
.PP
Again, see Config::Model::Node for more details on configuration
class declaration.
.PP
For convenience, \f(CW\*(C`experience\*(C'\fR, \f(CW\*(C`level\*(C'\fR and \f(CW\*(C`description\*(C'\fR parameters
can also be declared within the element declaration:
.PP
.Vb 10
\&  $model\->create_config_class 
\&  (
\&   config_class_name => \*(AqSomeRootClass\*(Aq,
\&   class_description => "SomeRootClass description",
\&   \*(Aqelement\*(Aq
\&   => [ 
\&        tree_macro => { level => \*(Aqimportant\*(Aq,
\&                        experience => \*(Aqadvanced\*(Aq,
\&                      },
\&        warp       => { experience => \*(Aqadvanced\*(Aq, } ,
\&        X          => { description => \*(AqX\-ray\*(Aq, } ,
\&      ] 
\&  ) ;
.Ve
.SH "Load pre-declared model"
.IX Header "Load pre-declared model"
You can also load pre-declared model.
.SS "load( <model_name> )"
.IX Subsection "load( <model_name> )"
This method will open the model directory and execute a \f(CW\*(C`.pl\*(C'\fR
file containing the model declaration,
.PP
This perl file must return an array ref to declare models. E.g.:
.PP
.Vb 10
\& [
\&  [
\&   name => \*(AqClass_1\*(Aq,
\&   element => [ ... ]
\&  ],
\&  [
\&   name => \*(AqClass_2\*(Aq,
\&   element => [ ... ]
\&  ]
\& ];
.Ve
.PP
do not put \f(CW\*(C`1;\*(C'\fR at the end or \f(CW\*(C`load\*(C'\fR will not work
.PP
If a model name contain a \f(CW\*(C`::\*(C'\fR (e.g \f(CW\*(C`Foo::Bar\*(C'\fR), \f(CW\*(C`load\*(C'\fR will look for
a file named \f(CW\*(C`Foo/Bar.pl\*(C'\fR.
.PP
Returns a list containining the names of the loaded classes. For instance, if 
\&\f(CW\*(C`Foo/Bar.pl\*(C'\fR contains a model for \f(CW\*(C`Foo::Bar\*(C'\fR and \f(CW\*(C`Foo::Bar2\*(C'\fR, \f(CW\*(C`load\*(C'\fR
will return \f(CW\*(C`( \*(AqFoo::Bar\*(Aq , \*(AqFoo::Bar2\*(Aq )\*(C'\fR.
.SH "Model query"
.IX Header "Model query"
.SS "get_model( config_class_name )"
.IX Subsection "get_model( config_class_name )"
Return a hash containing the model declaration.
.SS "get_element_model( config_class_name , element)"
.IX Subsection "get_element_model( config_class_name , element)"
Return a hash containing the model declaration for the specified class
and element.
.SS "get_element_name( class => Foo, for => advanced )"
.IX Subsection "get_element_name( class => Foo, for => advanced )"
Get all names of the elements of class \f(CW\*(C`Foo\*(C'\fR that are accessible for
experience level \f(CW\*(C`advanced\*(C'\fR.
.PP
Level can be \f(CW\*(C`master\*(C'\fR (default), \f(CW\*(C`advanced\*(C'\fR or \f(CW\*(C`beginner\*(C'\fR.
.SS "list_class_element"
.IX Subsection "list_class_element"
Returns a string listing all the class and elements. Useful for
debugging your configuration model.
.SH "Error handling"
.IX Header "Error handling"
Errors are handled with an exception mechanism (See
Exception::Class).
.PP
When a strongly typed Value object gets an authorized value, it raises
an exception. If this exception is not catched, the programs exits.
.PP
See Config::Model::Exception for details on
the various exception classes provided with \f(CW\*(C`Config::Model\*(C'\fR.
.SH "Log and Traces"
.IX Header "Log and Traces"
Currently a rather lame trace mechanism is provided:
.IP "\(bu" 4
Set \f(CW$::debug\fR to 1 to get debug messages on \s-1STDOUT\s0.
.IP "\(bu" 4
Set \f(CW$::verbose\fR to 1 to get verbose messages on \s-1STDOUT\s0.
.PP
Depending on available time, a better log/error system may be
implemented.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dominique Dumont, (ddumont at cpan dot org)
.SH "LICENSE"
.IX Header "LICENSE"
.Vb 1
\&    Copyright (c) 2005\-2010 Dominique Dumont.
\&
\&    This file is part of Config\-Model.
\&
\&    Config\-Model is free software; you can redistribute it and/or
\&    modify it under the terms of the GNU Lesser Public License as
\&    published by the Free Software Foundation; either version 2.1 of
\&    the License, or (at your option) any later version.
\&
\&    Config\-Model is distributed in the hope that it will be useful,
\&    but WITHOUT ANY WARRANTY; without even the implied warranty of
\&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
\&    Lesser Public License for more details.
\&
\&    You should have received a copy of the GNU Lesser Public License
\&    along with Config\-Model; if not, write to the Free Software
\&    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
\&    02110\-1301 USA
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Config::Model::Instance,
.PP
http://sourceforge.net/apps/mediawiki/config\-model/index.php?title=Creating_a_model
.SS "Model elements"
.IX Subsection "Model elements"
The arrow shows the inheritance of the classes
.IP "\(bu" 4
Config::Model::Node <\- Config::Model::AutoRead <\- Config::Model::AnyThing
.IP "\(bu" 4
Config::Model::HashId <\- Config::Model::AnyId <\- Config::Model::WarpedThing <\- Config::Model::AnyThing
.IP "\(bu" 4
Config::Model::ListId <\- Config::Model::AnyId <\- Config::Model::WarpedThing <\- Config::Model::AnyThing
.IP "\(bu" 4
Config::Model::Value <\- Config::Model::WarpedThing <\- Config::Model::AnyThing
.IP "\(bu" 4
Config::Model::CheckList <\- Config::Model::WarpedThing <\- Config::Model::AnyThing
.IP "\(bu" 4
Config::Model::WarpedNode <\- Config::Model::WarpedThing <\- Config::Model::AnyThing
.SS "command line"
.IX Subsection "command line"
config-edit
.SS "Read and write backends"
.IX Subsection "Read and write backends"
.IP "\(bu" 4
Config::Model::Backend::IniFile <\- Config::Model::Backend::Any
.IP "\(bu" 4
Config::Model::Backend::ShellVar <\- Config::Model::Backend::Any
.IP "\(bu" 4
Config::Model::Backend::Yaml <\- Config::Model::Backend::Any
.SS "Model utilities"
.IX Subsection "Model utilities"
.IP "\(bu" 4
Config::Model::Annotation
.IP "\(bu" 4
Config::Model::Describe
.IP "\(bu" 4
Config::Model::Dumper
.IP "\(bu" 4
Config::Model::DumpAsData
.IP "\(bu" 4
Config::Model::Loader
.IP "\(bu" 4
Config::Model::ObjTreeScanner
.IP "\(bu" 4
Config::Model::Report
.IP "\(bu" 4
Config::Model::Searcher
.IP "\(bu" 4
Config::Model::TermUI
.IP "\(bu" 4
Config::Model::WizardHelper
.IP "\(bu" 4
Config::Model::AutoRead
.IP "\(bu" 4
Config::Model::ValueComputer
