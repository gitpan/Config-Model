.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Model::Node 3pm"
.TH Config::Model::Node 3pm "2010-10-19" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Model::Node \- Class for configuration tree node
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& $model\->create_config_class 
\&  (
\&   name              => \*(AqOneConfigClass\*(Aq,
\&   class_description => "OneConfigClass detailed description",
\&
\&   element           => [
\&                          [qw/X Y Z/] 
\&                          => {
\&                               type => \*(Aqleaf\*(Aq,
\&                               value_type => \*(Aqenum\*(Aq,
\&                               choice     => [qw/Av Bv Cv/]
\&                             }
\&                        ],
\&
\&   experience        => [ Y => \*(Aqbeginner\*(Aq, 
\&                          X => \*(Aqmaster\*(Aq 
\&                        ],
\&   status            => [ X => \*(Aqdeprecated\*(Aq ],
\&   description       => [ X => \*(AqX\-ray description (can be long)\*(Aq ],
\&   summary           => [ X => \*(AqX\-ray\*(Aq ],
\&
\&   accept            => [ { name_match => \*(Aqip.*\*(Aq,
\&                            type => \*(Aqleaf\*(Aq,
\&                            value_type => \*(Aquniline\*(Aq,
\&                            summary => \*(Aqip address\*(Aq,
\&                          }
\&                        ]
\&  );
\&
\& my $instance = $model\->instance (root_class_name => \*(AqOneConfigClass\*(Aq, 
\&                                  instance_name => \*(Aqtest1\*(Aq);
\& my $root_node = $instance \-> config_root ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides the nodes of a configuration tree. When created, a
node object will get a set of rules that will define its properties
within the configuration tree.
.PP
Each node contain a set of elements. An element can contain:
.IP "\(bu" 4
A leaf element implemented with Config::Model::Value. A leaf can be
plain (unconstrained value) or be strongly typed (values are checked
against a set of rules).
.IP "\(bu" 4
Another node.
.IP "\(bu" 4
A collection of items: a list element, implemented with
Config::Model::ListId. Each item can be another node or a leaf.
.IP "\(bu" 4
A collection of identified items: a hash element, implemented with
Config::Model::HashId.  Each item can be another node or a leaf.
.SH "Configuration class declaration"
.IX Header "Configuration class declaration"
A class declaration is made of the following parameters:
.IP "\fBname\fR" 4
.IX Item "name"
Mandatory \f(CW\*(C`string\*(C'\fR parameter. This config class name can be used by a node
element in another configuration class.
.IP "\fBclass_description\fR" 4
.IX Item "class_description"
Optional \f(CW\*(C`string\*(C'\fR parameter. This description will be used when
generating user interfaces.
.IP "\fBelement\fR" 4
.IX Item "element"
Mandatory \f(CW\*(C`list ref\*(C'\fR of elements of the configuration class :
.Sp
.Vb 3
\&  element => [ foo => { type = \*(Aqleaf\*(Aq, ... },
\&               bar => { type = \*(Aqleaf\*(Aq, ... }
\&             ]
.Ve
.Sp
Element names can be grouped to save typing:
.Sp
.Vb 1
\&  element => [ [qw/foo bar/] => { type = \*(Aqleaf\*(Aq, ... } ]
.Ve
.Sp
See below for details on element declaration.
.IP "\fBexperience\fR" 4
.IX Item "experience"
Optional \f(CW\*(C`list ref\*(C'\fR of the elements whose experience are different
from default value (\f(CW\*(C`beginner\*(C'\fR). Possible values are \f(CW\*(C`master\*(C'\fR,
\&\f(CW\*(C`advanced\*(C'\fR and \f(CW\*(C`beginner\*(C'\fR.
.Sp
.Vb 3
\&  experience   => [ Y => \*(Aqbeginner\*(Aq, 
\&                    [qw/foo bar/] => \*(Aqmaster\*(Aq 
\&                  ],
.Ve
.IP "\fBlevel\fR" 4
.IX Item "level"
Optional \f(CW\*(C`list ref\*(C'\fR of the elements whose level are different from
default value (\f(CW\*(C`normal\*(C'\fR). Possible values are \f(CW\*(C`important\*(C'\fR, \f(CW\*(C`normal\*(C'\fR
or \f(CW\*(C`hidden\*(C'\fR.
.Sp
The level is used to set how configuration data is presented to the
user in browsing mode. \f(CW\*(C`Important\*(C'\fR elements will be shown to the user
no matter what. \f(CW\*(C`hidden\*(C'\fR elements will be explained with the \fIwarp\fR
notion.
.Sp
.Vb 1
\&  level  => [ [qw/X Y/] => \*(Aqimportant\*(Aq ]
.Ve
.IP "\fBstatus\fR" 4
.IX Item "status"
Optional \f(CW\*(C`list ref\*(C'\fR of the elements whose status are different from
default value (\f(CW\*(C`standard\*(C'\fR). Possible values are \f(CW\*(C`obsolete\*(C'\fR,
\&\f(CW\*(C`deprecated\*(C'\fR or \f(CW\*(C`standard\*(C'\fR.
.Sp
Using a deprecated element will issue a warning. Using an obsolete
element will raise an exception (See Config::Model::Exception.
.Sp
.Vb 1
\&  status  => [ [qw/X Y/] => \*(Aqobsolete\*(Aq ]
.Ve
.IP "\fBdescription\fR" 4
.IX Item "description"
Optional \f(CW\*(C`list ref\*(C'\fR of element description. These descriptions will
be used when generating user interfaces.
.IP "\fBdescription\fR" 4
.IX Item "description"
Optional \f(CW\*(C`list ref\*(C'\fR of element summary. These descriptions will be
used when generating user interfaces or as comment when writing
configuration files.
.IP "\fBread_config\fR" 4
.IX Item "read_config"
.PD 0
.IP "\fBwrite_config\fR" 4
.IX Item "write_config"
.IP "\fBconfig_dir\fR" 4
.IX Item "config_dir"
.PD
Parameters used to load on demand configuration data. 
See Config::Model::AutoRead for details.
.IP "\fBaccept\fR" 4
.IX Item "accept"
Optional list of criteria to accept unknown parameters. Each criteria will have
a list of specification that will enable \f(CW\*(C`Config::Model\*(C'\fR to create a model
snippet for the unknown element.
.Sp
Example:
.Sp
.Vb 10
\&  accept =>      [
\&                    {
\&                            name_match => \*(Aqlist.*\*(Aq,
\&                            type => \*(Aqlist\*(Aq,
\&                            cargo => {
\&                                        type => \*(Aqleaf\*(Aq,
\&                                        value_type => \*(Aqstring\*(Aq,
\&                                     } ,
\&                     },
\&                     {
\&                            name_match => \*(Aqstr.*\*(Aq,
\&                            type => \*(Aqleaf\*(Aq,
\&                            value_type => \*(Aquniline\*(Aq
\&                     },
\&                  ]
.Ve
.Sp
All \f(CW\*(C`element\*(C'\fR parameter and \f(CW\*(C`name_match\*(C'\fR can be used for \f(CW\*(C`accept\*(C'\fR.
.SH "Element declaration"
.IX Header "Element declaration"
.SS "Element type"
.IX Subsection "Element type"
Each element is declared with a list ref that contains all necessary
information:
.PP
.Vb 3
\&  element => [ 
\&               foo => { ... }
\&             ]
.Ve
.PP
This most important information from this hash ref is the mandatory
\&\fBtype\fR parameter. The \fItype\fR type can be:
.ie n .IP """node""" 8
.el .IP "\f(CWnode\fR" 8
.IX Item "node"
The element is a simple node of a tree instanciated from a 
configuration class (declared with 
\&\*(L"create_config_class( ... )\*(R" in Config::Model). 
See \*(L"Node element\*(R".
.ie n .IP """warped_node""" 8
.el .IP "\f(CWwarped_node\fR" 8
.IX Item "warped_node"
The element is a node whose properties (mostly \f(CW\*(C`config_class_name\*(C'\fR)
can be changed (warped) according to the values of one or more leaf
elements in the configuration tree.  See Config::Model::WarpedNode
for details.
.ie n .IP """leaf""" 8
.el .IP "\f(CWleaf\fR" 8
.IX Item "leaf"
The element is a scalar value. See \*(L"Leaf element\*(R"
.ie n .IP """hash""" 8
.el .IP "\f(CWhash\fR" 8
.IX Item "hash"
The element is a collection of nodes or values (default). Each 
element of this collection is identified by a string (Just like a regular
hash, except that you can set up constraint of the keys).
See \*(L"Hash element\*(R"
.ie n .IP """list""" 8
.el .IP "\f(CWlist\fR" 8
.IX Item "list"
The element is a collection of nodes or values (default). Each element
of this collection is identified by an integer (Just like a regular
perl array, except that you can set up constraint of the keys).  See
\&\*(L"List element\*(R"
.ie n .IP """check_list""" 8
.el .IP "\f(CWcheck_list\fR" 8
.IX Item "check_list"
The element is a collection of values which are unique in the
check_list. See CheckList.
.SS "Node element"
.IX Subsection "Node element"
When declaring a \f(CW\*(C`node\*(C'\fR element, you must also provide a
\&\f(CW\*(C`config_class_name\*(C'\fR parameter. For instance:
.PP
.Vb 10
\& $model \->create_config_class 
\&   (
\&   name => "ClassWithOneNode",
\&   element => [
\&                the_node => { 
\&                              type => \*(Aqnode\*(Aq,
\&                              config_class_name => \*(AqAnotherClass\*(Aq,
\&                            },
\&              ]
\&   ) ;
.Ve
.SS "Leaf element"
.IX Subsection "Leaf element"
When declaring a \f(CW\*(C`leaf\*(C'\fR element, you must also provide a
\&\f(CW\*(C`value_type\*(C'\fR parameter. See Config::Model::Value for more details.
.SS "Hash element"
.IX Subsection "Hash element"
When declaring a \f(CW\*(C`hash\*(C'\fR element, you must also provide a
\&\f(CW\*(C`index_type\*(C'\fR parameter.
.PP
You can also provide a \f(CW\*(C`cargo_type\*(C'\fR parameter set to \f(CW\*(C`node\*(C'\fR or
\&\f(CW\*(C`leaf\*(C'\fR (default).
.PP
See Config::Model::HashId and Config::Model::AnyId for more
details.
.SS "List element"
.IX Subsection "List element"
You can also provide a \f(CW\*(C`cargo_type\*(C'\fR parameter set to \f(CW\*(C`node\*(C'\fR or
\&\f(CW\*(C`leaf\*(C'\fR (default).
.PP
See Config::Model::ListId and Config::Model::AnyId for more
details.
.SH "Introspection methods"
.IX Header "Introspection methods"
.SS "name"
.IX Subsection "name"
Returns the location of the node, or its config class name (for root
node).
.SS "get_type"
.IX Subsection "get_type"
Returns \f(CW\*(C`node\*(C'\fR.
.SS "config_model"
.IX Subsection "config_model"
Returns the \fBentire\fR configuration model (Config::Model object).
.SS "model"
.IX Subsection "model"
Returns the configuration model of this node (data structure).
.SS "config_class_name"
.IX Subsection "config_class_name"
Returns the configuration class name of this node.
.SS "instance"
.IX Subsection "instance"
Returns the instance object containing this node. Inherited from 
Config::Model::AnyThing
.SS "has_element ( element_name )"
.IX Subsection "has_element ( element_name )"
Returns 1 if the class model has the element declared or if the element 
name is matched by the optional \f(CW\*(C`accept\*(C'\fR parameter.
.SS "find_element ( element_name , [ case => any ])"
.IX Subsection "find_element ( element_name , [ case => any ])"
Returns \f(CW$name\fR if the class model has the element declared or if the element 
name is matched by the optional \f(CW\*(C`accept\*(C'\fR parameter.
.PP
If case is set to any, has_element will return the element name who match the passed
name in a case-insensitive manner.
.PP
Returns empty if no matching element is found.
.SS "searcher ()"
.IX Subsection "searcher ()"
Returns an object dedicated to search an element in the configuration
model (respecting privilege level).
.PP
This method returns a Config::Model::Searcher object. See
Config::Model::Searcher for details on how to handle a search.
.PP
This method is inherited from Config::Model::AnyThing.
.SS "element_model ( element_name )"
.IX Subsection "element_model ( element_name )"
Returns model of the element.
.SS "element_type ( element_name )"
.IX Subsection "element_type ( element_name )"
Returns the type (e.g. leaf, hash, list, checklist or node) of the
element.
.SS "\fIelement_name()\fP"
.IX Subsection "element_name()"
Returns the element name that contain this object. Inherited from 
Config::Model::AnyThing
.SS "\fIindex_value()\fP"
.IX Subsection "index_value()"
See \*(L"\fIindex_value()\fR\*(R" in Config::Model::AnyThing
.SS "\fIparent()\fP"
.IX Subsection "parent()"
See \*(L"\fIparent()\fR\*(R" in Config::Model::AnyThing
.SS "\fIroot()\fP"
.IX Subsection "root()"
See \*(L"\fIroot()\fR\*(R" in Config::Model::AnyThing
.SS "\fIlocation()\fP"
.IX Subsection "location()"
See \*(L"\fIlocation()\fR\*(R" in Config::Model::AnyThing
.SH "Element property management"
.IX Header "Element property management"
.SS "get_element_name ( for => <experience>, ...  )"
.IX Subsection "get_element_name ( for => <experience>, ...  )"
Return all elements names available for \f(CW\*(C`experience\*(C'\fR.
If no experience is specified, will return all
slots available at 'master' level (I.e all elements).
.PP
Optional paremeters are:
.IP "\(bu" 4
\&\fBtype\fR: Returns only element of requested type (e.g. \f(CW\*(C`list\*(C'\fR,
\&\f(CW\*(C`hash\*(C'\fR, \f(CW\*(C`leaf\*(C'\fR,...). By default return elements of any type.
.IP "\(bu" 4
\&\fBcargo_type\fR: Returns only element which contain requested type.
E.g. if \f(CW\*(C`get_element_name\*(C'\fR is called with \f(CW\*(C`cargo_type => leaf\*(C'\fR,
\&\f(CW\*(C`get_element_name\*(C'\fR will return simple leaf elements, but also hash
or list element that contain leaf object. By
default return elements of any type.
.PP
Returns an array in array context, and a string 
(e.g. \f(CW\*(C`join(\*(Aq \*(Aq,@array)\*(C'\fR) in scalar context.
.SS "next_element ( element_name, [ experience_index ] )"
.IX Subsection "next_element ( element_name, [ experience_index ] )"
This method provides a way to iterate through the elements of a node.
.PP
Returns the next element name for a given experience (default
\&\f(CW\*(C`master\*(C'\fR).  Returns undef if no next element is available.
.SS "previous_element ( element_name, [ experience_index ] )"
.IX Subsection "previous_element ( element_name, [ experience_index ] )"
This method provides a way to iterate through the elements of a node.
.PP
Returns the previous element name for a given experience (default
\&\f(CW\*(C`master\*(C'\fR).  Returns undef if no previous element is available.
.SS "get_element_property ( element => ..., property => ... )"
.IX Subsection "get_element_property ( element => ..., property => ... )"
Retrieve a property of an element.
.PP
I.e. for a model :
.PP
.Vb 3
\&  experience => [ X => \*(Aqmaster\*(Aq],
\&  status     => [ X => \*(Aqdeprecated\*(Aq ]
\&  element    => [ X => { ... } ]
.Ve
.PP
This call will return \f(CW\*(C`deprecated\*(C'\fR:
.PP
.Vb 1
\&  $node\->get_element_property ( element => \*(AqX\*(Aq, property => \*(Aqstatus\*(Aq )
.Ve
.SS "set_element_property ( element => ..., property => ... )"
.IX Subsection "set_element_property ( element => ..., property => ... )"
Set a property of an element.
.SS "reset_element_property ( element => ... )"
.IX Subsection "reset_element_property ( element => ... )"
Reset a property of an element according to the original model.
.SH "Information management"
.IX Header "Information management"
.SS "fetch_element ( name => ..  [ , user_experience => .. ] , [ check => ..] )"
.IX Subsection "fetch_element ( name => ..  [ , user_experience => .. ] , [ check => ..] )"
Fetch and returns an element from a node.
.PP
If user_experience is given, this method will check that the user has
enough privilege to access the element. If not, a \f(CW\*(C`RestrictedElement\*(C'\fR
exception will be raised.
.PP
check can be set to yes, no or skip
.SS "fetch_element_value ( name => ... [ check => ...] )"
.IX Subsection "fetch_element_value ( name => ... [ check => ...] )"
Fetch and returns the \fIvalue\fR of a leaf element from a node.
.PP
If user_experience is given, this method will check that the user has
enough privilege to access the element. If not, a \f(CW\*(C`RestrictedElement\*(C'\fR
exception will be raised.
.SS "store_element_value ( name, value )"
.IX Subsection "store_element_value ( name, value )"
Store a \fIvalue\fR in a leaf element from a node.
.PP
Can be invoked with named parameters (name, value, experience, check)
.PP
If user_experience is given, this method will check that the user has
enough privilege to access the element. If not, a \f(CW\*(C`RestrictedElement\*(C'\fR
exception will be raised.
.SS "is_element_available( name => ...,  experience => ... )"
.IX Subsection "is_element_available( name => ...,  experience => ... )"
Returns 1 if the element \f(CW\*(C`name\*(C'\fR is available for the given
\&\f(CW\*(C`experience\*(C'\fR ('beginner' by default) and if the element is
not \*(L"hidden\*(R". Returns 0 otherwise.
.PP
As a syntactic sugar, this method can be called with only one parameter:
.PP
.Vb 1
\&   is_element_available( \*(Aqelement_name\*(Aq ) ;
.Ve
.SS "accept_element( name )"
.IX Subsection "accept_element( name )"
Checks and returns the appropriate model of an acceptable element 
(be it explicetely declared, or part of an \f(CW\*(C`accept\*(C'\fR declaration).
Returns undef if the element cannot be accepted.
.SS "accept_regexp( name )"
.IX Subsection "accept_regexp( name )"
Returns the list of regular expressions used to check for acceptable parameters. 
Useful for diagnostics.
.SS "element_exists( element_name )"
.IX Subsection "element_exists( element_name )"
Returns 1 if the element is known in the model.
.SS "is_element_defined( element_name )"
.IX Subsection "is_element_defined( element_name )"
Returns 1 if the element is defined.
.SS "grab(...)"
.IX Subsection "grab(...)"
See \*(L"grab(...)\*(R" in Config::Model::AnyThing.
.SS "grab_value(...)"
.IX Subsection "grab_value(...)"
See \*(L"grab_value(...)\*(R" in Config::Model::AnyThing.
.SS "\fIgrab_root()\fP"
.IX Subsection "grab_root()"
See \*(L"\fIgrab_root()\fR\*(R" in Config::Model::AnyThing.
.SS "get( path  [ custom | preset | standard | default ])"
.IX Subsection "get( path  [ custom | preset | standard | default ])"
Get a value from a directory like path.
.SS "set( path  , value)"
.IX Subsection "set( path  , value)"
Set a value from a directory like path.
.SH "Serialisation"
.IX Header "Serialisation"
.SS "load ( step => string [, experience => ... ] )"
.IX Subsection "load ( step => string [, experience => ... ] )"
Load configuration data from the string into the node and its siblings.
.PP
This string follows the syntax defined in Config::Model::Loader.
See \*(L"load ( ... )\*(R" in Config::Model::Loader for details on parameters.
\&\f(CW\*(C`experience\*(C'\fR is 'master' by default.
.PP
This method can also be called with a single parameter:
.PP
.Vb 1
\&  $node\->load("some data:to be=loaded");
.Ve
.ie n .SS "load_data ( hash_ref, hash_ref,[ $check  ])"
.el .SS "load_data ( hash_ref, hash_ref,[ \f(CW$check\fP  ])"
.IX Subsection "load_data ( hash_ref, hash_ref,[ $check  ])"
Load configuration data with a hash ref (first parameter). The hash ref key must match
the available elements of the node. The hash ref structure must match
the structure of the configuration model.
.PP
The second parameter is optional and contains annotations for
elements. A standard hash of hash (or list) may contain annotation
only for leaf elements. In order to support annotation for nodes or
other elements, hash keys can also contain annotations like \*(L"foo# foo
note\*(R".  Also the special key '_\|_' will store the annotation in the
containing object.
.SS "dump_tree ( ... )"
.IX Subsection "dump_tree ( ... )"
Dumps the configuration data of the node and its siblings into a
string.  See \*(L"dump_tree\*(R" in Config::Model::Dumper for parameter details.
.PP
This string follows the syntax defined in
Config::Model::Loader. The string produced by \f(CW\*(C`dump_tree\*(C'\fR can be
passed to \f(CW\*(C`load\*(C'\fR.
.SS "describe ( [ element => ... ] )"
.IX Subsection "describe ( [ element => ... ] )"
Provides a decription of the node elements or of one element.
.SS "report ()"
.IX Subsection "report ()"
Provides a text report on the content of the configuration below this
node.
.SS "audit ()"
.IX Subsection "audit ()"
Provides a text audit on the content of the configuration below this
node. This audit will show only value different from their default
value.
.SS "copy_from ( another_node_object )"
.IX Subsection "copy_from ( another_node_object )"
Copy configuration data from another node into this node and its
siblings. The copy is made in a \fItolerant\fR mode where invalid data
are simply discarded.
.SH "Help management"
.IX Header "Help management"
.SS "get_help ( [ [ description | summary ] => element_name ] )"
.IX Subsection "get_help ( [ [ description | summary ] => element_name ] )"
If called without element, returns the description of the class
(Stored in \f(CW\*(C`class_description\*(C'\fR attribute of a node declaration).
.PP
If called with an element name, returns the description of the
element (Stored in \f(CW\*(C`description\*(C'\fR attribute of a node declaration).
.PP
If called with 2 argument, either return the \f(CW\*(C`summary\*(C'\fR or the
\&\f(CW\*(C`description\*(C'\fR of the element.
.PP
Returns an empty string if no description was found.
.SS "AutoRead nodes"
.IX Subsection "AutoRead nodes"
As configuration model are getting bigger, the load time of a tree
gets longer. The Config::Model::AutoRead class provides a way to
load the configuration information only when needed.
.PP
\&\s-1TBD\s0
.SH "AUTHOR"
.IX Header "AUTHOR"
Dominique Dumont, (ddumont at cpan dot org)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Config::Model, 
Config::Model::Instance, 
Config::Model::HashId,
Config::Model::ListId,
Config::Model::CheckList,
Config::Model::WarpedNode,
Config::Model::Value
