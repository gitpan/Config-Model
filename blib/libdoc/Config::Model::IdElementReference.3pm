.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Model::IdElementReference 3pm"
.TH Config::Model::IdElementReference 3pm "2010-10-19" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Model::IdElementReference \- Refer to id element(s) and extract keys
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\& # used from a value class
\& element => [
\&            node_host => { type => \*(Aqleaf\*(Aq,
\&                           value_type => \*(Aqreference\*(Aq ,
\&                           refer_to => \*(Aq! host\*(Aq
\&                         },
\&            if   => { type => \*(Aqleaf\*(Aq,
\&                      value_type => \*(Aqreference\*(Aq ,
\&                      computed_refer_to 
\&                      => { formula => \*(Aq  ! host:$h if \*(Aq,
\&                           variables => { h => \*(Aq\- node_host\*(Aq }
\&                         }
\&                    },
\&            ],
\&
\&  # used from checklist
\&  element => [
\&              # simple reference, checklist items are given by the
\&              # keys of my_hash
\&              refer_to_list => { type => \*(Aqcheck_list\*(Aq,
\&                                 refer_to => \*(Aq\- my_hash\*(Aq
\&                               },
\&
\&              # checklist items are given by combining my_hash*
\&              refer_to_2_list
\&                            => { type => \*(Aqcheck_list\*(Aq,
\&                                 refer_to => \*(Aq\- my_hash + \- my_hash2   + \- my_hash3\*(Aq
\&                               },
\&             ]
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is user by Config::Model::Value to set up an enumerated
value where the possible choice depends on the key of a
Config::Model::HashId or the content of a Config::Model::ListId
object.
.PP
This class is also used by Config::Model::CheckList to define the
cheklist items from the keys of another hash (or content of a list).
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
Construction is handled by the calling object.
.SH "Config class parameters"
.IX Header "Config class parameters"
.IP "refer_to" 4
.IX Item "refer_to"
\&\f(CW\*(C`refer_to\*(C'\fR is used to specify a hash element that will be used as a
reference. \f(CW\*(C`refer_to\*(C'\fR points to an array or hash element in the
configuration tree using the path syntax (See
\&\*(L"grab\*(R" in Config::Model::Node for details).
.IP "computed_refer_to" 4
.IX Item "computed_refer_to"
When \f(CW\*(C`computed_refer_to\*(C'\fR is used, the path is computed using values
from several elements in the configuration tree. \f(CW\*(C`computed_refer_to\*(C'\fR
is a hash with 2 mandatory elements: \f(CW\*(C`formula\*(C'\fR and \f(CW\*(C`variables\*(C'\fR.
.PP
The available choice of this (computed or not) reference value is made
from the available keys of the refered_to hash element or the values
of the refered_to array element.
.PP
The example means the the value must correspond to an existing host:
.PP
.Vb 2
\& value_type => \*(Aqreference\*(Aq,
\& refer_to => \*(Aq! host\*(Aq
.Ve
.PP
This example means the the value must correspond to an existing lan
within the host whose Id is specified by hostname:
.PP
.Vb 4
\& value_type => \*(Aqreference\*(Aq,
\& computed_refer_to => { formula => \*(Aq! host:$a lan\*(Aq, 
\&                        variables => { a => \*(Aq\- hostname\*(Aq }
\&                      }
.Ve
.PP
If you need to combine possibilities from several hash, use the "\f(CW\*(C`+\*(C'\fR"
token to separate 2 paths:
.PP
.Vb 4
\& value_type => \*(Aqreference\*(Aq,
\& computed_refer_to => { formula => \*(Aq! host:$a lan + ! host:foobar lan\*(Aq, 
\&                        variables => { a => \*(Aq\- hostname\*(Aq }
\&                      }
.Ve
.PP
You can specify \f(CW\*(C`refer_to\*(C'\fR or \f(CW\*(C`computed_refer_to\*(C'\fR with a \f(CW\*(C`choice\*(C'\fR
argument so the possible enum value will be the combination of the
specified choice and the refered_to values.
.SH "Methods"
.IX Header "Methods"
.SS "reference_info"
.IX Subsection "reference_info"
Returns a human readable string with explains how is retrieved the
reference. This method is mostly used to construct an error messages.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dominique Dumont, (ddumont at cpan dot org)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Config::Model, Config::Model::Value,
Config::Model::AnyId, Config::Model::CheckList
