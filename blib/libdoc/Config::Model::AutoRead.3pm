.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Model::AutoRead 3pm"
.TH Config::Model::AutoRead 3pm "2010-10-19" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Model::AutoRead \- Load configuration node on demand
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  # top level config file name matches instance name
\&  $model\->create_config_class 
\&  (
\&   name => \*(AqOneAutoReadConfigClass\*(Aq,
\&
\&   read_config  => [ { backend => \*(Aqcds_file\*(Aq , config_dir => \*(Aq/etc/cfg_dir\*(Aq},
\&                     { backend => \*(Aqcustom\*(Aq , 
\&                       class => \*(AqProcessRead\*(Aq ,
\&                       config_dir => \*(Aq/etc/foo\*(Aq, # optional
\&                       file  => \*(Aqfoo.conf\*(Aq,      # optional
\&                       auto_create => 1,         # optional
\&                     }
\&                   ],
\&   # if omitted, write_config will be written using read_config specifications
\&   # write_config can be array of hash ref to write several syntaxes
\&   write_config => { backend => \*(Aqcds_file\*(Aq, config_dir => \*(Aq/etc/cfg_dir\*(Aq } ,
\&
\&
\&   element => ...
\&  ) ;
\&
\&  # config data will be written in /etc/my_config_dir/foo.cds
\&  # according to the instance name
\&  my $instance = $model\->instance(instance_name => \*(Aqfoo\*(Aq) ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides a way to specify how to load or store
configuration data within the model (instead of writing dedicated perl
code).
.PP
With these specifications, all the configuration information is read
during creation of a node.
.PP
This load/store can be done with different \f(CW\*(C`backend\*(C'\fR:
.IP "cds_file" 4
.IX Item "cds_file"
Config dump string (cds) in a file. I.e. a string that describes the
content of a configuration tree is loaded from or saved in a text
file. See Config::Model::Dumper.
.IP "ini_file" 4
.IX Item "ini_file"
Ini files (written with Config::Model::Backend::IniFile. See limitations in 
\&\*(L"Limitations depending on storage\*(R".
.IP "perl_file" 4
.IX Item "perl_file"
Perl data structure (perl) in a file. See Config::Model::DumpAsData
for details on the data structure.
.IP "custom" 4
.IX Item "custom"
Any format when the user provides a dedicated class and function to
read and load the configuration tree.
.IP "augeas" 4
.IX Item "augeas"
Data can be loaded or stored using RedHat's Augeas library. See
Config::Model::Backend::Augeas for details.
.PP
After loading the data, the object registers itself to the
instance. Then the user can call the \f(CW\*(C`write_back\*(C'\fR method on the
instance (See Config::Model::Instance) to store all configuration
information back.
.SS "Built-in backend"
.IX Subsection "Built-in backend"
\&\f(CW\*(C`cds_file\*(C'\fR, \f(CW\*(C`ini_file\*(C'\fR and \f(CW\*(C`perl_file\*(C'\fR backend must be specified with
mandatory \f(CW\*(C`config_dir\*(C'\fR parameter. For instance:
.PP
.Vb 4
\&   read_config  => { backend    => \*(Aqcds_file\*(Aq , 
\&                     config_dir => \*(Aq/etc/cfg_dir\*(Aq,
\&                     file       => \*(Aqcfg_file.cds\*(Aq, #optional
\&                   },
.Ve
.PP
If \f(CW\*(C`file\*(C'\fR is not specified, a file name will be constructed with
\&\f(CW\*(C`<config_class_name>.<suffix>\*(C'\fR where suffix is \f(CW\*(C`pl\*(C'\fR or \f(CW\*(C`ini\*(C'\fR or \f(CW\*(C`cds\*(C'\fR.
.SS "Plugin backend classes"
.IX Subsection "Plugin backend classes"
A plugin backend class can also be specified with:
.PP
.Vb 5
\&  read_config  => [ { backend    => \*(Aqfoo\*(Aq , 
\&                      config_dir => \*(Aq/etc/cfg_dir\*(Aq
\&                      file       => \*(Aqfoo.conf\*(Aq, # optional
\&                    }
\&                  ]
.Ve
.PP
In this case, this class will try to load \f(CW\*(C`Config::Model::Backend::Foo\*(C'\fR.
(The class name is constructed with \f(CW\*(C`ucfirst($backend_name)\*(C'\fR)
.PP
\&\f(CW\*(C`read_config\*(C'\fR can also have custom parameters that will passed
verbatim to \f(CW\*(C`Config::Model::Backend::Foo\*(C'\fR methods:
.PP
.Vb 5
\&  read_config  => [ { backend    => \*(Aqfoo\*(Aq , 
\&                      config_dir => \*(Aq/etc/cfg_dir\*(Aq,
\&                      my_param   => \*(Aqmy_value\*(Aq,
\&                    } 
\&                  ]
.Ve
.PP
This \f(CW\*(C`Config::Model::Backend::Foo\*(C'\fR class is expected to provide the
following methods:
.IP "new" 4
.IX Item "new"
with parameters:
.Sp
.Vb 1
\& node => ref_to_config_model_node
.Ve
.Sp
\&\f(CW\*(C`new()\*(C'\fR must return the newly created object
.IP "read" 4
.IX Item "read"
with parameters:
.Sp
.Vb 6
\& %custom_parameters,      # model data
\& root => $root_dir,       # mostly used for tests
\& config_dir => $read_dir, # path below root
\& file_path => $full_name, # full file name (root+path+file)
\& io_handle => $io_file    # IO::File object
\& check     => [ yes|no|skip]
.Ve
.Sp
Must return 1 if the read was successful, 0 otherwise.
.Sp
Following the \f(CW\*(C`my_param\*(C'\fR example above, \f(CW%custom_parameters\fR will contain 
\&\f(CW\*(C` ( \*(Aqmy_param\*(Aq , \*(Aqmy_value\*(Aq ) \*(C'\fR, so \f(CW\*(C`read()\*(C'\fR will also be called with
\&\f(CW\*(C`root\*(C'\fR, \f(CW\*(C`config_dir\*(C'\fR, \f(CW\*(C`file_path\*(C'\fR, \f(CW\*(C`io_handle\*(C'\fR \fBand\fR
\&\f(CW\*(C`my_param   => \*(Aqmy_value\*(Aq\*(C'\fR.
.IP "write" 4
.IX Item "write"
with parameters:
.Sp
.Vb 8
\& %$write,                     # model data
\& auto_create => $auto_create, # from model
\& backend     => $backend,     # backend name
\& config_dir  => $write_dir,   # override from instance
\& io_handle   => $fh,          # IO::File object
\& write       => 1,            # always
\& check       => [ yes|no|skip] ,
\& root        => $root_dir,
.Ve
.Sp
Must return 1 if the write was successful, 0 otherwise
.SS "Custom backend"
.IX Subsection "Custom backend"
Custom backend must be specified with a class name that will features
the methods used to write and read the configuration files:
.PP
.Vb 5
\&  read_config  => [ { backend => \*(Aqcustom\*(Aq , 
\&                      class => \*(AqMyRead\*(Aq,
\&                      config_dir => \*(Aq/etc/foo\*(Aq, # optional
\&                      file => \*(Aqfoo.conf\*(Aq,       # optional
\&                    } ]
.Ve
.PP
\&\f(CW\*(C`custom\*(C'\fR backend parameters are:
.IP "class" 4
.IX Item "class"
Specify the class that contain the read method
.IP "config_dir" 4
.IX Item "config_dir"
Specify configuration directory. This parameter is optional as the
directory can be hardcoded in the custom class.
.IP "file" 4
.IX Item "file"
optional. This parameter may not apply if the configuration is stored
in several files. By default, the instance name is used as
configuration file name.
.IP "function" 4
.IX Item "function"
Function name that will be called back to read the file. 
See \*(L"read callback\*(R" for details. (default is \f(CW\*(C`read\*(C'\fR)
.IP "auto_create" 4
.IX Item "auto_create"
By default, an exception is thrown if no read was
successfull. This behavior can be overridden by specifying 
\&\f(CW\*(C`auto_create => 1\*(C'\fR in one of the backend specification. For instance:
.Sp
.Vb 5
\&    read_config  => [ { backend => \*(Aqcds_file\*(Aq, config_dir => \*(Aq/etc/my_cfg/\*(Aq } , 
\&                      { backend => \*(Aqcustom\*(Aq, class => \*(AqBar\*(Aq ,
\&                        auto_create => 1
\&                      },
\&                    ],
.Ve
.Sp
This feature is necessary to create a configuration from scratch
.Sp
When set in write backend, missing directory and files will be created
with current umask. Default is false.
.PP
Write specification is similar to read_specification. Except that the
default value for \f(CW\*(C`function\*(C'\fR is \f(CW\*(C`write\*(C'\fR. Here's an example:
.PP
.Vb 5
\&   write_config  => [ { backend => \*(Aqcds_file\*(Aq, config_dir => \*(Aq/etc/my_cfg/\*(Aq } , 
\&                      { backend => \*(Aqcustom\*(Aq, class => \*(AqBar\*(Aq ,
\&                        function => \*(Aqmy_write\*(Aq,
\&                      },
\&                    ],
.Ve
.SH "Limitations depending on storage"
.IX Header "Limitations depending on storage"
Some storage system will limit the structure of the model you can map
to the file.
.SS "Ini files limitation"
.IX Subsection "Ini files limitation"
Structure of the Config::Model must be very simple. Either:
.IP "\(bu" 4
A single class with hash of leaves elements.
.IP "\(bu" 4
2 levels of classes. The top level has nodes elements. All other
classes have only leaf elements.
.SH "Configuration class with auto read or auto write"
.IX Header "Configuration class with auto read or auto write"
.SS "read specification"
.IX Subsection "read specification"
A configuration class will be declared with optional \f(CW\*(C`read_config\*(C'\fR
parameter:
.PP
.Vb 3
\&  read_config  => [ { backend => \*(Aqcds_file\*(Aq, config_dir => \*(Aq/etc/my_cfg/\*(Aq } , 
\&                    { backend => \*(Aqcustom\*(Aq, class => \*(AqBar\*(Aq },
\&                  ],
.Ve
.PP
The read backends will be tried in the specified order:
.IP "\(bu" 4
First the cds file whose name depend on the parameters used in model
creation and instance creation:
\&\f(CW\*(C`<model_config_dir>/<instance_name>.cds\*(C'\fR
The syntax of the \f(CW\*(C`cds\*(C'\fR file is described in  Config::Model::Dumper.
.IP "\(bu" 4
A callback to \f(CW\*(C`Bar::read\*(C'\fR. See "\*(L"read callback\*(R" for details.
.PP
When a read operation is successful, the remaining read methods will
be skipped.
.SS "write specification"
.IX Subsection "write specification"
A configuration class will be declared with optional \f(CW\*(C`write_config\*(C'\fR
parameters (along with \f(CW\*(C`read_config\*(C'\fR parameter):
.PP
.Vb 3
\&  write_config => [ { backend => \*(Aqcds_file\*(Aq, config_dir => \*(Aq/etc/my_cfg/\*(Aq,
\&                      auto_create => 1, },
\&                    { backend => \*(Aqcustom\*(Aq, class => \*(AqNewFormat\*(Aq } ],
.Ve
.PP
By default, the specifications are tried in order, until the first succeeds.
.PP
When required by the user, all configuration information is written
back using \fBall\fR the write specifications. See
\&\*(L"write_back ( ... )\*(R" in Config::Model::Instance for details.
.PP
The write class declared witn \f(CW\*(C`custom\*(C'\fR backend must provide a call-back.
See \*(L"write callback\*(R" for details.
.SS "read write directory"
.IX Subsection "read write directory"
By default, configurations files are read from the directory specified
by \f(CW\*(C`config_dir\*(C'\fR parameter specified in the model. You may override the
\&\f(CW\*(C`root\*(C'\fR directory for test.
.SS "read callback"
.IX Subsection "read callback"
Read callback function will be called with these parameters:
.PP
.Vb 7
\&  object     => $obj,         # Config::Model::Node object 
\&  root       => \*(Aq./my_test\*(Aq,  # fake root directory, userd for tests
\&  config_dir => /etc/foo\*(Aq,    # absolute path 
\&  file       => \*(Aqfoo.conf\*(Aq,   # file name
\&  file_path  => \*(Aq./my_test/etc/foo/foo.conf\*(Aq 
\&  io_handle  => $io           # IO::File object with binmode :utf8
\&  check      => [yes|no|skip]
.Ve
.PP
The IO::File object is undef if the file cannot be read.
.PP
The callback must return 0 on failure and 1 on succesfull read.
.SS "write callback"
.IX Subsection "write callback"
Write callback function will be called with these parameters:
.PP
.Vb 9
\&  object      => $obj,         # Config::Model::Node object 
\&  root        => \*(Aq./my_test\*(Aq,  # fake root directory, userd for tests
\&  config_dir  => /etc/foo\*(Aq,    # absolute path 
\&  file        => \*(Aqfoo.conf\*(Aq,   # file name
\&  file_path  => \*(Aq./my_test/etc/foo/foo.conf\*(Aq 
\&  io_handle   => $io           # IO::File object opened in write mode 
\&                               # with binmode :utf8
\&  auto_create => 1             # create dir as needed
\&  check      => [yes|no|skip]
.Ve
.PP
The IO::File object is undef if the file cannot be written to.
.PP
The callback must return 0 on failure and 1 on succesfull write.
.SH "CAVEATS"
.IX Header "CAVEATS"
When both \f(CW\*(C`config_dir\*(C'\fR and \f(CW\*(C`file\*(C'\fR are specified, this class will
write-open the configuration file (and thus clobber it) before calling
the \f(CW\*(C`write\*(C'\fR call-back and pass the file handle with \f(CW\*(C`io_handle\*(C'\fR
parameter. \f(CW\*(C`write\*(C'\fR should use this handle to write data in the target
configuration file.
.PP
If this behavior causes problem (e.g. with augeas backend), the
solution is to:
.IP "\(bu" 4
Skip either \f(CW\*(C`file\*(C'\fR or \f(CW\*(C`config_dir\*(C'\fR parameter in the \f(CW\*(C`write_config\*(C'\fR
specification.
.IP "\(bu" 4
Create a \f(CW\*(C`skip_open\*(C'\fR function in your backend class that returns \f(CW1\fR
.SH "EXAMPLES"
.IX Header "EXAMPLES"
In the example below, only a \f(CW\*(C`cds\*(C'\fR file is written. But, both custom
format and \f(CW\*(C`cds\*(C'\fR file are tried for read. This is also an example of
a graceful migration from a customized format to a \f(CW\*(C`cds\*(C'\fR format.
.PP
.Vb 4
\&  read_config  => [ { backend => \*(Aqcds_file\*(Aq, config_dir => \*(Aq/etc/my_cfg/\*(Aq } , 
\&                    { backend => \*(Aqcustom\*(Aq, class => \*(AqBar\*(Aq },
\&                  ],
\&  write_config => [{ backend => \*(Aqcds_file\*(Aq, config_dir => \*(Aq/etc/my_cfg/\*(Aq }],
.Ve
.PP
You can choose also to read and write only customized files:
.PP
.Vb 1
\&  read_config  => [{ backend => \*(Aqcustom\*(Aq, class => \*(AqBar\*(Aq}],
.Ve
.PP
Or to read and write only cds files :
.PP
.Vb 1
\&  read_config  => [{ backend => \*(Aqcds_file\*(Aq}] ,
.Ve
.PP
You can also specify more parameters that must be passed to your
custom class:
.PP
.Vb 2
\&  read_config  => [{ backend => \*(Aqcustom\*(Aq, class => \*(AqBar\*(Aq, 
\&                    config_dir => \*(Aq/etc/foo\*(Aq}],
.Ve
.PP
To migrate from an old format to a new format:
.PP
.Vb 10
\&  read_config  => [ { backend => \*(Aqcustom\*(Aq,
\&                      class => \*(AqOldFormat\*(Aq,
\&                      function => \*(Aqold_read\*(Aq
\&                    } ,
\&                    { backend => \*(Aqcustom\*(Aq,
\&                      class => \*(AqNewFormat\*(Aq,
\&                      function => \*(Aqnew_read\*(Aq
\&                    }
\&                  ],
\&  write_config => [ { backend => \*(Aqcustom\*(Aq,
\&                      class => \*(AqNewFormat\*(Aq
\&                    }
\&                  ],
.Ve
.PP
If \f(CW\*(C`write_config\*(C'\fR is missing, the data provided by \f(CW\*(C`read_config\*(C'\fR
will be used. For instance:
.PP
.Vb 4
\&  read_config  => [ { backend => \*(Aqcustom\*(Aq,
\&                      class => \*(AqBar\*(Aq,
\&                      config_dir => \*(Aq/etc/foo\*(Aq
\&                  } ],
.Ve
.PP
In this case, configuration data will be read by \f(CW\*(C`Bar::read\*(C'\fR in
directory \f(CW\*(C`/etc/foo\*(C'\fR and will be written back there by \f(CW\*(C`Bar::write\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dominique Dumont, (ddumont at cpan dot org)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Config::Model, Config::Model::Instance,
Config::Model::Node, Config::Model::Dumper, Config::Augeas
