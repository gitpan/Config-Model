.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Model::WarpedNode 3pm"
.TH Config::Model::WarpedNode 3pm "2010-10-19" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Model::WarpedNode \- Node that change config class properties
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 9
\& $model \->create_config_class 
\&  (
\&   name => \*(AqClass_with_one_changing_node\*(Aq,
\&   element =>
\&   [
\&    tree_macro => {type => \*(Aqleaf\*(Aq,
\&                   value_type => \*(Aqenum\*(Aq,
\&                   choice     => [qw/XY XZ mXY W/]
\&                  },
\&
\&    \*(Aqa_warped_node\*(Aq
\&    => {
\&        type => \*(Aqwarped_node\*(Aq,
\&        follow  => \*(Aq! tree_macro\*(Aq,
\&        morph   => 1,
\&        rules => {
\&                  XY  => { config_class_name => [\*(AqSlaveY\*(Aq], },
\&                  mXY => {
\&                          config_class_name   => \*(AqSlaveY\*(Aq,
\&                          experience => \*(Aqintermediate\*(Aq
\&                         },
\&                  XZ => { config_class_name => \*(AqSlaveZ\*(Aq }
\&                 }
\&       },
\&
\&    \*(Aqanother_warped_node\*(Aq
\&    => {
\&        type => \*(Aqwarped_node\*(Aq,
\&        follow  => { tm => \*(Aq! tree_macro\*(Aq},
\&        morph   => 1,
\&        rules => [
\&                  \*(Aq$tm eq "XY"\*(Aq  => { config_class_name => [\*(AqSlaveY\*(Aq], },
\&                  \*(Aq$tm eq "mXY"\*(Aq => {
\&                                    config_class_name   => \*(AqSlaveY\*(Aq,
\&                                    experience => \*(Aqintermediate\*(Aq
\&                                  },
\&                  \*(Aq$tm eq "XZ"\*(Aq  => { config_class_name => \*(AqSlaveZ\*(Aq }
\&                 ]
\&       },
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides a way to change dynamically the configuration
class (or some other properties) of a node. The changes are done
according to the model declaration.
.PP
This declaration will specify one (or several) leaf in the
configuration tree that will trigger the actual property change of the
warped node. This leaf is also refered as \fIwarp master\fR.
.PP
When the warp master(s) value(s) changes, WarpedNode will create an instance
of the new class required by the warp master.
.PP
If the morph parameter is set, the values held by the old object are
(if possible) copied to the new instance of the object using
copy_from
method.
.PP
Warped node can alter the following properties:
.PP
.Vb 3
\& config_class_name
\& experience
\& level
.Ve
.SH "Constructor"
.IX Header "Constructor"
WarpedNode should not be created directly.
.SH "Warped node model declaration"
.IX Header "Warped node model declaration"
.SS "Parameter overview"
.IX Subsection "Parameter overview"
A warped node must be declared with the following parameters:
.IP "type" 4
.IX Item "type"
Always set to \f(CW\*(C`warped_node\*(C'\fR.
.IP "follow" 4
.IX Item "follow"
Grab string leading to the
\&\f(CW\*(C`Config::Model::Value\*(C'\fR warp master.
See \*(L"Warp follow argument\*(R" in Config::Model::WarpedThing for details.
.IP "morph" 4
.IX Item "morph"
boolean. If 1, WarpedNode will try to recursively copy the value from
the old object to the new object using 
copy_from method.
When a copy is not possible, undef values
will be assigned to object elements.
.IP "rules" 4
.IX Item "rules"
Hash or array ref that specify the property change rules according to the
warp master(s) value(s). 
See \*(L"Warp rules argument\*(R" in Config::Model::WarpedThing for details 
on how to specify the warp master values (or combination of values).
.SS "Effect declaration"
.IX Subsection "Effect declaration"
For a warped node, the effects are declared with these parameters:
.IP "\fBconfig_class_name\fR" 8
.IX Item "config_class_name"
When requested by the warp master,the WarpedNode will create a new
object of the type specified by this parameter:
.Sp
.Vb 1
\&  XZ => { config_class_name => \*(AqSlaveZ\*(Aq }
.Ve
.Sp
If you pass an array ref, the array will contain the class name and
constructor arguments :
.Sp
.Vb 1
\&  XY  => { config_class_name => [\*(AqSlaveY\*(Aq, foo => \*(Aqbar\*(Aq ], },
.Ve
.IP "\fBexperience\fR" 8
.IX Item "experience"
Switch the experience of the slot when the object is warped in.
.SH "Forwarded methods"
.IX Header "Forwarded methods"
The following methods are forwared to contained node:
.PP
fetch_element config_class_name get_element_name has_element
is_element_available element_type load fetch_element_value get_type
get_cargo_type describe config_model
.SH "Methods"
.IX Header "Methods"
.SS "name"
.IX Subsection "name"
Return the name of the node (even if warped out).
.SS "is_accessible"
.IX Subsection "is_accessible"
Returns true if the node hidden behind this warped node is accessible,
i.e. the warp master have values so a node was warped in.
.SS "get_actual_node"
.IX Subsection "get_actual_node"
Returns the node object hidden behind the warped node. Croaks if the
node is not accessible.
.SS "load_data ( hash_ref )"
.IX Subsection "load_data ( hash_ref )"
Load configuration data with a hash ref. The hash ref key must match
the available elements of the node carried by the warped node.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
.Vb 10
\& $model \->create_config_class 
\&  (
\&   experience => [ bar => \*(Aqadvanced\*(Aq] ,
\&   element =>
\&    [
\&     tree_macro => { type => \*(Aqleaf\*(Aq,
\&                     value_type => \*(Aqenum\*(Aq,
\&                     choice     => [qw/XX XY XZ ZZ/]
\&                   },
\&     bar =>  {
\&               type => \*(Aqwarped_node\*(Aq,
\&               follow => \*(Aq! tree_macro\*(Aq, 
\&               morph => 1,
\&               rules => [
\&                         XX => { config_class_name 
\&                                   => [ \*(AqClassX\*(Aq, \*(Aqfoo\*(Aq ,\*(Aqbar\*(Aq ]}
\&                         XY => { config_class_name => \*(AqClassY\*(Aq},
\&                         XZ => { config_class_name => \*(AqClassZ\*(Aq}
\&                        ]
\&             }
\&    ]
\&  );
.Ve
.PP
In the example above we see that:
.IP "\(bu" 4
The 'bar' slot can refer to a ClassX, ClassZ or ClassY object.
.IP "\(bu" 4
The warper object is the \f(CW\*(C`tree_macro\*(C'\fR attribute of the root of the
object tree.
.IP "\(bu" 4
When \f(CW\*(C`tree_macro\*(C'\fR is set to \f(CW\*(C`ZZ\*(C'\fR, \f(CW\*(C`bar\*(C'\fR will not be available. Trying to
access bar will raise an exception.
.IP "\(bu" 4
When \f(CW\*(C`tree_macro\*(C'\fR is changed from \f(CW\*(C`ZZ\*(C'\fR to \f(CW\*(C`XX\*(C'\fR, 
\&\f(CW\*(C`bar\*(C'\fR will refer to a brand new ClassX 
object constructed with \f(CW\*(C`ClassX\->new(foo => \*(Aqbar\*(Aq)\*(C'\fR
.IP "\(bu" 4
Then, if \f(CW\*(C`tree_macro\*(C'\fR is changed from \f(CW\*(C`XX\*(C'\fR to \f(CW\*(C`XY\*(C'\fR, \f(CW\*(C`bar\*(C'\fR will
refer to a brand new ClassY object. But in this case, the object will be
initialized with most if not all the attributes of ClassX. This copy
will be done whenever \f(CW\*(C`tree_macro\*(C'\fR is changed.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dominique Dumont, (ddumont at cpan dot org)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Config::Model::Instance, 
Config::Model, 
Config::Model::HashId,
Config::Model::ListId,
Config::Model::AnyThing,
Config::Model::WarpedThing,
Config::Model::WarpedNode,
Config::Model::Value
