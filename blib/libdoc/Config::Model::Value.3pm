.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Model::Value 3pm"
.TH Config::Model::Value 3pm "2010-10-19" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Model::Value \- Strongly typed configuration value
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\& my $model = Config::Model\->new() ;
\& $model \->create_config_class 
\&  (
\&   name => "SomeClass",
\&   element => [
\&     country => { 
\&       type =>       \*(Aqleaf\*(Aq,
\&       value_type => \*(Aqenum\*(Aq,
\&       choice =>      [qw/France US/]
\&     },
\&     president => { 
\&       type =>        \*(Aqleaf\*(Aq,
\&       value_type => \*(Aqstring\*(Aq,
\&       warp => { 
\&         follow => { c => \*(Aq\- country\*(Aq}, 
\&         rules  => {
\&           \*(Aq$c eq "France"\*(Aq => { default => \*(AqChirac\*(Aq },
\&           \*(Aq$c eq "US"\*(Aq     => { default => \*(AqBush\*(Aq }
\&         }
\&       },
\&     }
\&   ]
\& );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides a way to specify configuration value with the
following properties:
.IP "\(bu" 4
Strongly typed scalar: the value can either be an enumerated type, a boolean,
a number, an integer or a string
.IP "\(bu" 4
default parameter: a value can have a default value specified during
the construction. This default value will be written in the target
configuration file. (\f(CW\*(C`default\*(C'\fR parameter)
.IP "\(bu" 4
upstream default parameter: specifies a default value that will be
used by the application when no information is provided in the
configuration file. This upstream_default value will not written in
the configuration files. Only the \f(CW\*(C`fetch_standard\*(C'\fR method will return
the builtin value. This parameter was previously refered as
\&\f(CW\*(C`built_in\*(C'\fR value. This may be used for audit
purpose. (\f(CW\*(C`upstream_default\*(C'\fR parameter)
.IP "\(bu" 4
mandatory value: reading a mandatory value will raise an exception if the
value is not specified and has no default value.
.IP "\(bu" 4
dynamic change of property: A slave value can be registered to another
master value so that the properties of the slave value can change
according to the value of the master value. For instance, paper size value
can be 'letter' for country '\s-1US\s0' and 'A4' for country 'France'.
.IP "\(bu" 4
A reference to the Id of a hash of list element. In other word, the
value is an enumerated type where the possible values (choice) is
defined by the existing keys of a has element somewhere in the tree. See
\&\*(L"Value Reference\*(R".
.SH "Default values"
.IX Header "Default values"
There are several kind of default values. They depend on where these
values are defined (or found).
.PP
From the lowest default level to the \*(L"highest\*(R":
.IP "\(bu" 4
\&\f(CW\*(C`upstream_default\*(C'\fR: The value is knows in the application, but is not
written in the configuration file.
.IP "\(bu" 4
\&\f(CW\*(C`default\*(C'\fR: The value is known by the model, but not by the
application. This value must be written in the configuration file.
.IP "\(bu" 4
\&\f(CW\*(C`computed\*(C'\fR: The value is computed from other configuration
elements. This value must be written in the configuration file.
.IP "\(bu" 4
\&\f(CW\*(C`preset\*(C'\fR: The value is not known by the model or by the
application. But it can be found by an automatic program and stored
while the configuration Config::Model::Instance is in 
Config::Model::Instance/\*(L"preset_start ()\*(R"
.PP
Then there is the value entered by the user. This will override all
kind of \*(L"default\*(R" value.
.PP
The fetch_standard function will return the \*(L"highest\*(R" level of
default value, but will not return a custom value, i.e. a value
entered by the user.
.SH "Constructor"
.IX Header "Constructor"
Value object should not be created directly.
.SH "Value model declaration"
.IX Header "Value model declaration"
A leaf element must be declared with the following parameters:
.IP "value_type" 4
.IX Item "value_type"
Either \f(CW\*(C`boolean\*(C'\fR, \f(CW\*(C`enum\*(C'\fR, \f(CW\*(C`integer\*(C'\fR, \f(CW\*(C`number\*(C'\fR,
\&\f(CW\*(C`uniline\*(C'\fR, \f(CW\*(C`string\*(C'\fR. Mandatory. See \*(L"Value types\*(R".
.IP "default" 4
.IX Item "default"
Specify the default value (optional)
.IP "upstream_default" 4
.IX Item "upstream_default"
Specify a built in default value (optional)
.IP "compute" 4
.IX Item "compute"
Will compute a value according to a formula and other values. By default
a computed value cannot be set. See Config::Model::ValueComputer for 
computed value declaration.
.IP "migrate_from" 4
.IX Item "migrate_from"
This is a special parameter to cater for smooth configuration
upgrade. This parameter can be used to copy the value of a deprecated
parameter to its replacement. See \*(L"upgrade\*(R"\*(L" in \*(R" for details.
.IP "convert => [uc | lc ]" 4
.IX Item "convert => [uc | lc ]"
When stored, the value will be converted to uppercase (uc) or
lowercase (lc).
.IP "min" 4
.IX Item "min"
Specify the minimum value (optional, only for integer, number)
.IP "max" 4
.IX Item "max"
Specify the maximum value (optional, only for integer, number)
.IP "mandatory" 4
.IX Item "mandatory"
Set to 1 if the configuration value \fBmust\fR be set by the
configuration user (default: 0)
.IP "choice" 4
.IX Item "choice"
Array ref of the possible value of an enum. Example :
.Sp
.Vb 1
\& choice => [ qw/foo bar/]
.Ve
.IP "match" 4
.IX Item "match"
Perl regular expression. The value will be match with the regex to
assert its validity. Example \f(CW\*(C`match => \*(Aq^foo\*(Aq\*(C'\fR means that the
parameter value must begin with \*(L"foo\*(R". Valid only for \f(CW\*(C`string\*(C'\fR or
\&\f(CW\*(C`uniline\*(C'\fR values.
.IP "warn_if_match" 4
.IX Item "warn_if_match"
Perl regular expression. A warning will be issued when the value match the 
passed regular expression. Valid only for \f(CW\*(C`string\*(C'\fR or
\&\f(CW\*(C`uniline\*(C'\fR values.
.IP "warn_unless_match" 4
.IX Item "warn_unless_match"
Perl regular expression. A warning will be issued when the value does not match the 
passed regular expression. Valid only for \f(CW\*(C`string\*(C'\fR or
\&\f(CW\*(C`uniline\*(C'\fR values.
.IP "warn" 4
.IX Item "warn"
String. Issue a warning to user with the specified string any time a value is set or read.
.IP "grammar" 4
.IX Item "grammar"
Setup a Parse::RecDescent grammar to perform validation.
.Sp
If the grammar does not start with a \*(L"check\*(R" rule (i.e does not start with \*(L"check: \*(R"),
the first line of the grammar will be modified to add \*(L"check\*(R" rule and set up this rules so
the entire value must match the passed grammar.
.Sp
I.e. the grammar:
.Sp
.Vb 3
\&  token (oper token)(s?)
\&  oper: \*(Aqand\*(Aq | \*(Aqor\*(Aq
\&  token: \*(AqApache\*(Aq | \*(AqCC\-BY\*(Aq | \*(AqPerl\*(Aq
.Ve
.Sp
will be changed to
.Sp
.Vb 3
\&  check: token (oper token)(s?) /^\eZ/ {$return = 1;}
\&  oper: \*(Aqand\*(Aq | \*(Aqor\*(Aq
\&  token: \*(AqApache\*(Aq | \*(AqCC\-BY\*(Aq | \*(AqPerl\*(Aq
.Ve
.IP "replace" 4
.IX Item "replace"
Hash ref. Used for enum to substitute one value with another. This
parameter must be used to enable user to upgrade a configuration with
obsolete values. For instance, if the value \f(CW\*(C`foo\*(C'\fR is obsolete and
replaced by \f(CW\*(C`foo_better\*(C'\fR, you will need to declare:
.Sp
.Vb 1
\&  replace => { foo => \*(Aqfoo_better\*(Aq }
.Ve
.IP "refer_to" 4
.IX Item "refer_to"
Specify a path to an id element used as a reference. See Value
Reference for details.
.IP "computed_refer_to" 4
.IX Item "computed_refer_to"
Specify a pathto an id element used as a computed reference. See
\&\*(L"Value Reference\*(R" for details.
.IP "warp" 4
.IX Item "warp"
See section below: \*(L"Warp: dynamic value configuration\*(R".
.IP "help" 4
.IX Item "help"
You may provide detailed description on possible values with a hash
ref. Example:
.Sp
.Vb 1
\& help => { oui => "French for \*(Aqyes\*(Aq", non => "French for \*(Aqno\*(Aq"}
.Ve
.SS "Value types"
.IX Subsection "Value types"
This modules can check several value types:
.ie n .IP """boolean""" 4
.el .IP "\f(CWboolean\fR" 4
.IX Item "boolean"
Accepts values \f(CW1\fR or \f(CW0\fR, \f(CW\*(C`yes\*(C'\fR or \f(CW\*(C`no\*(C'\fR, \f(CW\*(C`true\*(C'\fR or \f(CW\*(C`false\*(C'\fR. The
value read back is always \f(CW1\fR or \f(CW0\fR.
.ie n .IP """enum""" 4
.el .IP "\f(CWenum\fR" 4
.IX Item "enum"
Enum choices must be specified by the \f(CW\*(C`choice\*(C'\fR parameter.
.ie n .IP """integer""" 4
.el .IP "\f(CWinteger\fR" 4
.IX Item "integer"
Enable positive or negative integer
.ie n .IP """number""" 4
.el .IP "\f(CWnumber\fR" 4
.IX Item "number"
The value can be a decimal number
.ie n .IP """uniline""" 4
.el .IP "\f(CWuniline\fR" 4
.IX Item "uniline"
A one line string. I.e without \*(L"\en\*(R" in it.
.ie n .IP """string""" 4
.el .IP "\f(CWstring\fR" 4
.IX Item "string"
Actually, no check is performed with this type.
.ie n .IP """reference""" 4
.el .IP "\f(CWreference\fR" 4
.IX Item "reference"
Like an \f(CW\*(C`enum\*(C'\fR where the possible values (aka choice) is defined by
another location if the configuration tree. See \*(L"Value Reference\*(R".
.SH "Warp: dynamic value configuration"
.IX Header "Warp: dynamic value configuration"
The Warp functionality enable a \f(CW\*(C`Value\*(C'\fR object to change its
properties (i.e. default value or its type) dynamically according to
the value of another \f(CW\*(C`Value\*(C'\fR object locate elsewhere in the
configuration tree. (See Config::Model::WarpedThing for an
explanation on warp mechanism).
.PP
For instance if you declare 2 \f(CW\*(C`Value\*(C'\fR element this way:
.PP
.Vb 10
\& $model \->create_config_class (
\&   name => "TV_config_class",
\&   element => [
\&     country => {
\&       type => \*(Aqleaf\*(Aq,
\&       value_type => \*(Aqenum\*(Aq, 
\&       choice => [qw/US Europe Japan/]
\&     },
\&     tv_standard => {
\&       type => \*(Aqleaf\*(Aq,
\&       value_type => \*(Aqenum\*(Aq,
\&       choice => [qw/PAL NTSC SECAM/]  
\&       warp => { 
\&         follow => { c => \*(Aq\- country\*(Aq }, # this points to the warp master
\&         rules => { 
\&           \*(Aq$c eq "US"\*(Aq     => { default => \*(AqNTSC\*(Aq  },
\&           \*(Aq$c eq "France"\*(Aq => { default => \*(AqSECAM\*(Aq },
\&           \*(Aq$c eq "Japan"\*(Aq  => { default => \*(AqNTSC\*(Aq  },
\&           \*(Aq$c eq "Europe"\*(Aq => { default => \*(AqPAL\*(Aq   },
\&         }
\&       }
\&     },
\&   ]
\& );
.Ve
.PP
Setting \f(CW\*(C`country\*(C'\fR element to \f(CW\*(C`US\*(C'\fR will mean that \f(CW\*(C`tv_standard\*(C'\fR has
a default value set to \f(CW\*(C`NTSC\*(C'\fR by the warp mechanism.
.PP
Likewise, the warp mechanism enables you to dynamically change the
possible values of an enum element:
.PP
.Vb 12
\& state => {
\&      type => \*(Aqleaf\*(Aq,
\&      value_type => \*(Aqenum\*(Aq, # example is admittedly silly
\&      warp =>{ 
\&         follow => { c => \*(Aq\- country\*(Aq },
\&         rules => { 
\&           \*(Aq$c eq "US"\*(Aq     => { choice => [\*(AqKansas\*(Aq, \*(AqTexas\*(Aq    ]},
\&           \*(Aq$c eq "Europe"\*(Aq => { choice => [\*(AqFrance\*(Aq, \*(AqSpain\*(Aq    ]},
\&           \*(Aq$c eq "Japan"\*(Aq  => { choice => [\*(AqHonshu\*(Aq, \*(AqHokkaido\*(Aq ]}
\&         }
\&      }
\&   }
.Ve
.SS "Cascaded warping"
.IX Subsection "Cascaded warping"
Warping value can be cascaded: \f(CW\*(C`A\*(C'\fR can be warped by \f(CW\*(C`B\*(C'\fR which can be
warped by \f(CW\*(C`C\*(C'\fR. But this feature should be avoided since it can lead
to a model very hard to debug. Bear in mind that:
.IP "\(bu" 4
Warp loop are not detected and will end up in \*(L"deep recursion
subroutine\*(R" failures.
.IP "\(bu" 4
If you declare \*(L"diamond\*(R" shaped warp dependencies, the results will
depend on the order of the warp algorithm and can be unpredictable.
.IP "\(bu" 4
The keys declared in the warp rules (\f(CW\*(C`US\*(C'\fR, \f(CW\*(C`Europe\*(C'\fR and \f(CW\*(C`Japan\*(C'\fR in
the example above) cannot be checked at start time against the warp
master \f(CW\*(C`Value\*(C'\fR. So a wrong warp rule key will be silently ignored
during start up and will fail at run time.
.SH "Value Reference"
.IX Header "Value Reference"
To set up an enumerated value where the possible choice depends on the
key of a Config::Model::AnyId object, you must:
.IP "\(bu" 4
Set \f(CW\*(C`value_type\*(C'\fR to \f(CW\*(C`reference\*(C'\fR.
.IP "\(bu" 4
Specify the \f(CW\*(C`refer_to\*(C'\fR or \f(CW\*(C`computed_refer_to\*(C'\fR parameter. 
See refer_to parameter.
.PP
In this case, a \f(CW\*(C`IdElementReference\*(C'\fR object is created to handle the
relation between this value object and the refered Id. See
Config::Model::IdElementReference for details.
.SH "Introspection methods"
.IX Header "Introspection methods"
The following methods returns the current value of the parameter of
the value object (as declared in the model unless they were warped):
.IP "min" 4
.IX Item "min"
.PD 0
.IP "max" 4
.IX Item "max"
.IP "mandatory" 4
.IX Item "mandatory"
.IP "choice" 4
.IX Item "choice"
.IP "convert" 4
.IX Item "convert"
.IP "value_type" 4
.IX Item "value_type"
.IP "default" 4
.IX Item "default"
.IP "upstream_default" 4
.IX Item "upstream_default"
.IP "index_value" 4
.IX Item "index_value"
.IP "element_name" 4
.IX Item "element_name"
.PD
.SS "\fIname()\fP"
.IX Subsection "name()"
Returns the object name.
.SS "get_type"
.IX Subsection "get_type"
Returns \f(CW\*(C`leaf\*(C'\fR.
.SS "\fIcan_store()\fP"
.IX Subsection "can_store()"
Returns true if the value object can be assigned to. Return 0 for a
read-only value (i.e. a computed value with no override allowed).
.SS "\fIget_choice()\fP"
.IX Subsection "get_choice()"
Query legal values (only for enum types). Return an array (possibly
empty).
.SS "get_help ( [ on_value ] )"
.IX Subsection "get_help ( [ on_value ] )"
Returns the help strings passed to the constructor.
.PP
With \f(CW\*(C`on_value\*(C'\fR parameter, returns the help string dedicated to the
passed value or undef.
.PP
Without parameter returns a hash ref that contains all the help strings.
.SS "warning_msg"
.IX Subsection "warning_msg"
Returns warning concerning this value. Returns a list in list 
context and a string in scalar context.
.SS "check_value ( value )"
.IX Subsection "check_value ( value )"
Check the consistency of the value. Does not check for undefined
mandatory values.
.PP
\&\f(CW\*(C`check_value\*(C'\fR also accepts named parameters:
.IP "value" 4
.IX Item "value"
.PD 0
.IP "quiet" 4
.IX Item "quiet"
.PD
When non null, check will not try to get extra
information from the tree. This is required in some cases to avoid
loops in check, get_info, get_warp_info, re-check ...
.IP "silent" 4
.IX Item "silent"
Don't display value warning on \s-1STDOUT\s0. User is expected to retrieve them witj
warning_msg.
.PP
In scalar context, return 0 or 1.
.PP
In array context, return an empty array when no error was found. In
case of errors, returns an array of error strings that should be shown
to the user.
.SS "check( value  )"
.IX Subsection "check( value  )"
Like \*(L"check_value\*(R". Also ensure that mandatory value are defined
.SH "Information management"
.IX Header "Information management"
.SS "store( value )"
.IX Subsection "store( value )"
Can be called as \f(CW\*(C`value => ...,  check => yes|no|skip )\*(C'\fR
.PP
Store value in leaf element. \f(CW\*(C`check\*(C'\fR parameter can be used to 
skip validation check.
.SS "load_data( scalar_value )"
.IX Subsection "load_data( scalar_value )"
Load scalar data. Data is simply forwarded to store.
.SS "fetch_custom"
.IX Subsection "fetch_custom"
Returns the stored value if this value is different from a standard
setting or built in seting. In other words, returns undef if the
stored value is identical to the default value or the computed value
or the built in value.
.SS "fetch_standard"
.IX Subsection "fetch_standard"
Returns the standard value as defined by the configuration model. The
standard value can be either a preset value, a computed value, a
default value or a built-in default value.
.SS "fetch( ... )"
.IX Subsection "fetch( ... )"
Check and fetch value from leaf element. The method can have one parameter (the fetch mode)
or several pairs:
.IP "mode" 4
.IX Item "mode"
Whether to fetch default, custom, etc value. See below for details
.IP "check" 4
.IX Item "check"
Whether to check if the value is valid or not before returning it. Default is 'yes'.
Possible value are
.RS 4
.IP "yes" 4
.IX Item "yes"
Perform check and raise an exception for bad values
.IP "skip" 4
.IX Item "skip"
Perform check and return undef for bad values
.IP "no" 4
.IX Item "no"
Do not check and return values even if bad
.RE
.RS 4
.RE
.IP "silent" 4
.IX Item "silent"
When set to 1, warning are not displayed on \s-1STDOUT\s0. User is expected to read warnings
with warning_msg.
.PP
According to the \f(CW\*(C`mode\*(C'\fR parameter, this method will return either:
.IP "empty mode parameter (default)" 4
.IX Item "empty mode parameter (default)"
Value entered by user or default value if the value is different from upstream_default
.IP "custom" 4
.IX Item "custom"
The value entered by the user (if different from built in, preset,
computed or default value)
.IP "preset" 4
.IX Item "preset"
The value entered in preset mode
.IP "standard" 4
.IX Item "standard"
The preset or computed or default or built in value.
.IP "default" 4
.IX Item "default"
The default value (defined by the configuration model)
.IP "upstream_default" 4
.IX Item "upstream_default"
The upstream_default value. (defined by the configuration model)
.IP "non_upstream_default" 4
.IX Item "non_upstream_default"
The custom or preset or computed or default value. Will return undef
if either of this value is identical to the upstream_default value. This
feature is useful to reduce data to write in configuration file.
.IP "allow_undef" 4
.IX Item "allow_undef"
This mode will accept to return undef for mandatory values. Normally,
trying to fetch an undefined mandatory value leads to an exception.
.SS "user_value"
.IX Subsection "user_value"
Returns the value entered by the user. Does not use the default or
computed value. Returns undef unless a value was actually stored.
.SS "fetch_preset"
.IX Subsection "fetch_preset"
Returns the value entered in preset mode. Does not use the default or
computed value. Returns undef unless a value was actually stored in
preset mode.
.SS "get( path , [ custom | preset | standard | default ])"
.IX Subsection "get( path , [ custom | preset | standard | default ])"
Get a value from a directory like path.
.SS "set( path , value )"
.IX Subsection "set( path , value )"
Set a value from a directory like path.
.SH "Upgrade"
.IX Header "Upgrade"
Upgrade is a special case when the configuration of an application has
changed. Some parameters can be removed and replaced by another
one. To avoid trouble on the application user side, Config::Model
offers a possibility to handle the migration of configuration data
through a special declaration in the configuration model.
.PP
This declaration must:
.IP "\(bu" 4
Declare the deprecated parameter with a \f(CW\*(C`status\*(C'\fR set to \f(CW\*(C`deprecated\*(C'\fR
.IP "\(bu" 4
Declare the new parameter with the intructions to load the semantic
content from the deprecated parameter. These instructions are declared
in the \f(CW\*(C`migrate_from\*(C'\fR parameters (which is similar to the \f(CW\*(C`compute\*(C'\fR
parameter)
.PP
Here an example where a url parameter is changed to a set of 2
parameters (host and path):
.PP
.Vb 10
\&       \*(Aqold_url\*(Aq => { type => \*(Aqleaf\*(Aq,
\&                      value_type => \*(Aquniline\*(Aq,
\&                      status => \*(Aqdeprecated\*(Aq,
\&                    },
\&       \*(Aqhost\*(Aq 
\&       => { type => \*(Aqleaf\*(Aq,
\&            value_type => \*(Aquniline\*(Aq,
\&            # the formula must end with \*(Aq$1\*(Aq so the result of the capture is used
\&            # as the host value
\&            migrate_from => { formula => \*(Aq$old =~ m!http://([\ew\e.]+)!; $1 ;\*(Aq , 
\&                              variables => { old => \*(Aq\- old_url\*(Aq } ,
\&                              use_eval => 1 ,
\&                            },
\&                        },
\&       \*(Aqpath\*(Aq => { type => \*(Aqleaf\*(Aq,
\&                   value_type => \*(Aquniline\*(Aq,
\&                   migrate_from => { formula => \*(Aq$old =~ m!http://[\ew\e.]+(/.*)!; $1 ;\*(Aq, 
\&                                     variables => { old => \*(Aq\- old_url\*(Aq } ,
\&                                     use_eval => 1 ,
\&                                   },
\&                 },
.Ve
.SH "EXCEPTION HANDLING"
.IX Header "EXCEPTION HANDLING"
When an error is encountered, this module may throw the following
exceptions:
.PP
.Vb 4
\& Config::Model::Exception::Model
\& Config::Model::Exception::Formula
\& Config::Model::Exception::WrongValue
\& Config::Model::Exception::WarpError
.Ve
.PP
See Config::Model::Exception for more details.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dominique Dumont, (ddumont at cpan dot org)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Config::Model, Config::Model::Node,
Config::Model::AnyId, Config::Model::WarpedThing, Exception::Class
Config::Model::ValueComputer,
