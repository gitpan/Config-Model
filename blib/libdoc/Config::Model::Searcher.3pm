.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Model::Searcher 3pm"
.TH Config::Model::Searcher 3pm "2010-10-19" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Model::Searcher \- Search an element in a configuration model
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Config::Model ;
\&
\& # create your config model
\& my $model = Config::Model \-> new ;
\& $model\->create_config_class( ... ) ;
\&
\& # create instance
\& my $inst = $model\->instance (root_class_name => \*(AqFooBar\*(Aq, 
\&                              instance_name => \*(Aqtest1\*(Aq);
\&
\& # create root of config
\& my $root = $inst \-> config_root ;
\&
\& # create searcher for manual search
\& my $searcher = $root\->searcher();
\& $searcher \-> prepare (element => \*(AqX\*(Aq) ;
\& my $step1 = $searcher\->next_step() ; # return possibilities
\& my $obj1 = $searcher\->choose($step1\->[0]) ;
\& my $step2 = $searcher\->next_step() ; # return possibilities
\& my $target = $searcher\->choose($step2\->[1]) ;
\&
\& # automatic search
\& my $element_call_back = sub { ... ; return \*(Aqfoo\*(Aq ;} ;
\& my $id_call_back      = sub { ... ; return \*(Aqbar\*(Aq ;} ;
\&
\& $searcher\->reset ;
\& my $target = $searcher\->auto_choose($element_call_back, $id_call_back) ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This modules provides a way to search for a configuration element in a
configuration tree.
.PP
For instance, suppose that you have a xorg.conf model and you know
that you need to tune the \f(CW\*(C`MergedXinerama\*(C'\fR parameter, but you don't
remember where is this parameter in the configuration tree. This module
will guide you through the tree to the(s) node(s) that contain this
parameter.
.PP
This class should be invaluable to construct interactive GUIs.
.PP
This module provides 2 search modes:
.IP "\(bu" 4
A manual search where you are guided step by step to the element
you're looking for. At each step, the module will return you the
possible paths to choose from. The user will have to choose the
correct path from the available paths. Most of the time, only one
possibility will be returned, so the user choice should be
straightforward. In other case (more that one choice), the user will
have to decide the next step.
.IP "\(bu" 4
An automatic search where you provide call-back that will resolve the
ambiguities in case of multiple paths.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
The constructor should be used only by Config::Model::Node.
.SH "Methods"
.IX Header "Methods"
.SS "get_searchable_elements"
.IX Subsection "get_searchable_elements"
Return the list of elements found in model that can be searched in the
configuration tree.
.SS "prepare(element => ...)"
.IX Subsection "prepare(element => ...)"
Prepare the searcher to look for the element passed in the argument.
Returns the searcher object (i.e. \f(CW$self\fR).
.SS "reset"
.IX Subsection "reset"
Re-initialise the search engine to redo the search from start
.SS "searched"
.IX Subsection "searched"
Returns the searched element name.
.SH "Manual search"
.IX Header "Manual search"
.SS "\fInext_step()\fP"
.IX Subsection "next_step()"
Returns an array ref containing the next possible step to find the
element you're looking for. The array ref can contain 1 or more
elements.
.PP
If the array ref is empty, you can get the target element with 
\&\*(L"\fIcurrent_object()\fR\*(R".
.SS "\fInext_choice()\fP"
.IX Subsection "next_choice()"
Returns an array ref containing the next non-obvious choice to find
the element you're looking for.
.PP
If the array ref is empty, you can get the target element with 
\&\*(L"\fIcurrent_object()\fR\*(R".
.SS "choose( <chosen_element_name> )"
.IX Subsection "choose( <chosen_element_name> )"
Tell the search engine your choice. The chosen element name must be
one of the possibilities given by \*(L"\fInext_step()\fR\*(R".
.SS "\fIcurrent_object()\fP"
.IX Subsection "current_object()"
Returns the object where the search engine is. It can be 
a node, 
a list, 
a hash, or 
a leaf element.
.SH "Automatic search"
.IX Header "Automatic search"
.SS "auto_choose ( element_callback, id_call_back)"
.IX Subsection "auto_choose ( element_callback, id_call_back)"
Finds the searched element with minimal user interaction.
.PP
\&\f(CW\*(C`element_callback\*(C'\fR will be called when the search engine finds a node
where more than one element can lead to the searched item.
.PP
\&\f(CW\*(C`id_call_back\*(C'\fR will be called when the search engine finds a hash
element or a list element which contain \fBno\fR or \fBmore than 1\fR
elements. In this case the call-back will have return an id that will
be used by the search engine to get the target element.
.PP
Both call-back arguments will be:
.IP "\(bu" 4
The current object (as returned by \*(L"\fIcurrent_object()\fR\*(R")
.IP "\(bu" 4
A list of possible choices
.PP
For instances, your callback will be :
.PP
.Vb 5
\& my $id_cb = sub {
\&    my ($object,@choices) = @_ ;
\&    ....
\&    return $choice[1] ;
\& }
.Ve
.PP
Both call-back are expected to return a scalar value that is either:
.IP "\(bu" 4
An element name
.IP "\(bu" 4
An id valid for the list or hash element returned by \*(L"\fIcurrent_object()\fR\*(R".
.SH "AUTHOR"
.IX Header "AUTHOR"
Dominique Dumont, (ddumont at cpan dot org)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Config::Model,
Config::Model::Node,
Config::Model::AnyId,
Config::Model::ListId,
Config::Model::HashId,
Config::Model::Value,
