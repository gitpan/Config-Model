.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Model::ObjTreeScanner 3pm"
.TH Config::Model::ObjTreeScanner 3pm "2010-10-19" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Model::ObjTreeScanner \- Scan config tree and perform call\-backs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Config::Model::ObjTreeScanner ;
\&
\& # define configuration tree object
\& my $root = ... ;
\&
\& # define leaf call back
\& my disp_leaf = sub { 
\&      my ($scanner, $data_ref, $node,$element_name,$index, $leaf_object) = @_ ;
\&      $$data_ref .= "$element_name = ", $leaf_object\->fetch ;
\&    } ;
\&
\& # simple scanner, (print all values with \*(Aqbeginner\*(Aq experience
\& $scan = Config::Model::ObjTreeScanner\-> new
\&  (
\&   leaf_cb               => \e&disp_leaf, # only mandatory parameter
\&  ) ;
\&
\& my $result = \*(Aq\*(Aq;
\&
\& $scan\->scan_node(\e$result, $root) ;
\& 
\&
\& # For a more complex scanner
\&
\& $scan = Config::Model::ObjTreeScanner\-> new
\&  (
\&   fallback => \*(Aqnone\*(Aq,     # all callback must be defined
\&   experience => \*(Aqmaster\*(Aq, # consider all values
\&
\&   # node callback
\&   node_content_cb               => \e&disp_obj_elt ,
\&
\&   # element callback
\&   list_element_cb       => \e&disp_hash    ,
\&   check_list_element_cb => \e&disp_hash    ,
\&   hash_element_cb       => \e&disp_hash    ,
\&   node_element_cb       => \e&disp_obj     ,
\&
\&   # leaf callback
\&   leaf_cb               => \e&disp_leaf,
\&   enum_value_cb         => \e&disp_leaf,
\&   integer_value_cb      => \e&disp_leaf,
\&   number_value_cb       => \e&disp_leaf,
\&   boolean_value_cb      => \e&disp_leaf,
\&   string_value_cb       => \e&disp_leaf,
\&   uniline_value_cb      => \e&disp_leaf,
\&   reference_value_cb    => \e&disp_leaf,
\&
\&   # call\-back when going up the tree
\&   up_cb                 => sub {} ,
\&  ) ;
\&
\& $scan\->scan_node(\e$result, $root) ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module creates an object that will explore (depth first) a
configuration tree.
.PP
For each part of the configuration tree, ObjTreeScanner object will
call-back one of the subroutine reference passed during construction.
.PP
Call-back routines will be called:
.IP "\(bu" 4
For each node containing elements (including root node)
.IP "\(bu" 4
For each element of a node. This element can be a list, hash, node or
simple leaf element.
.IP "\(bu" 4
For each item contained in a node, hash or list. This item can be a
simple leaf or another node.
.PP
To continue the exploration, these call-backs must also call the
scanner. (i.e. perform another call-back). In other words the user's
subroutine and the scanner plays a game of ping-pong until the tree is
completely explored.
.PP
The scanner provides a set of default callback for the nodes. This
way, the user only have to provide call-backs for the leaves.
.PP
The scan is started with a call to \f(CW\*(C`scan_node\*(C'\fR. The first parameter
of scan_node is a ref that is passed untouched to all call-back. This
ref may be used to store whatever result you want.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new ( ... )"
.IX Subsection "new ( ... )"
One way or another, the ObjTreeScanner object must be able to find all
callback for all the items of the tree. All the possible call-back are
listed below:
.IP "leaf callback:" 4
.IX Item "leaf callback:"
\&\f(CW\*(C`leaf_cb\*(C'\fR is a catch-all generic callback. All other are specialized
call-back : \f(CW\*(C`enum_value_cb\*(C'\fR, \f(CW\*(C`integer_value_cb\*(C'\fR, \f(CW\*(C`number_value_cb\*(C'\fR,
\&\f(CW\*(C`boolean_value_cb\*(C'\fR, \f(CW\*(C`string_value_cb\*(C'\fR, \f(CW\*(C`uniline_value_cb\*(C'\fR,
\&\f(CW\*(C`reference_value_cb\*(C'\fR
.IP "node callback:" 4
.IX Item "node callback:"
\&\f(CW\*(C`node_content_cb\*(C'\fR
.IP "element callback:" 4
.IX Item "element callback:"
All these call-backs are called on the elements of a node:
\&\f(CW\*(C`list_element_cb\*(C'\fR, \f(CW\*(C`check_list_element_cb\*(C'\fR, \f(CW\*(C`hash_element_cb\*(C'\fR,
\&\f(CW\*(C`node_element_cb\*(C'\fR, \f(CW\*(C`node_content_cb\*(C'\fR.
.PP
The user may specify all of them by passing the sub ref to the
constructor:
.PP
.Vb 6
\&   $scan = Config::Model::ObjTreeScanner\-> new
\&  (
\&   # node callback
\&   list_element_cb => sub ,
\&   ...
\&  )
.Ve
.PP
Or use some default callback using the fallback parameter. Note that
at least one callback must be provided: \f(CW\*(C`leaf_cb\*(C'\fR.
.PP
Optional parameter:
.IP "fallback" 4
.IX Item "fallback"
If set to 'node', the scanner will provide default call-back for node
items. If set to 'leaf', the scanner will set all leaf callback (like
enum_value_cb ...) to string_value_cb or to the mandatory leaf_cb
value. \*(L"fallback\*(R" callback will not override callbacks provided by the
user.
.Sp
If set to 'all', equivalent to 'node' and 'leaf'. By default, no
fallback is provided.
.IP "experience" 4
.IX Item "experience"
Set the privilege level used for the scan (default 'beginner').
.IP "auto_vivify" 4
.IX Item "auto_vivify"
Whether to create the configuration items while scan (default is 1).
.SH "Callback prototypes"
.IX Header "Callback prototypes"
.SS "Leaf callback"
.IX Subsection "Leaf callback"
\&\f(CW\*(C`leaf_cb\*(C'\fR is called for each leaf of the tree. The leaf callback will
be called with the following parameters:
.PP
.Vb 1
\& ($scanner, $data_ref,$node,$element_name,$index, $leaf_object)
.Ve
.PP
where:
.IP "\(bu" 4
\&\f(CW$scanner\fR is the scanner object.
.IP "\(bu" 4
\&\f(CW$data_ref\fR is a reference that is first passed to the first call of
the scanner. Then \f(CW$data_ref\fR is relayed through the various
call-backs
.IP "\(bu" 4
\&\f(CW$node\fR is the node that contain the leaf.
.IP "\(bu" 4
\&\f(CW$element_name\fR is the element (or attribute) that contain the leaf.
.IP "\(bu" 4
\&\f(CW$index\fR is the index (or hash key) used to get the leaf. This may
be undefined if the element type is scalar.
.IP "\(bu" 4
\&\f(CW$leaf_object\fR is a Config::Model::Value object.
.SS "List element callback"
.IX Subsection "List element callback"
\&\f(CW\*(C`list_element_cb\*(C'\fR is called on all list element of a node, i.e. call
on the list object itself and not in the elements contained in the
list.
.PP
.Vb 1
\& ($scanner, $data_ref,$node,$element_name,@indexes)
.Ve
.PP
\&\f(CW@indexes\fR is a list containing all the indexes of the list.
.PP
Example:
.PP
.Vb 2
\&  sub my_list_element_cb {
\&     my ($scanner, $data_ref,$node,$element_name,@idx) = @_ ;
\&
\&     # custom code using $data_ref
\&
\&     # resume exploration (if needed)
\&     map {$scanner\->scan_list($data_ref,$node,$element_name,$_)} @idx ;
\&
\&     # note: scan_list and scan_hash are equivalent
\&  }
.Ve
.SS "Check list element callback"
.IX Subsection "Check list element callback"
\&\f(CW\*(C`check_list_element_cb\*(C'\fR: Like \f(CW\*(C`list_element_cb\*(C'\fR, but called on a
check_list element.
.PP
.Vb 1
\& ($scanner, $data_ref,$node,$element_name,@check_items)
.Ve
.PP
\&\f(CW@check_items\fR is a list containing all the items of the check_list.
.SS "Hash element callback"
.IX Subsection "Hash element callback"
\&\f(CW\*(C`hash_element_cb\*(C'\fR: Like \f(CW\*(C`list_element_cb\*(C'\fR, but called on a
hash element.
.PP
.Vb 1
\& ($scanner, $data_ref,$node,$element_name,@keys)
.Ve
.PP
\&\f(CW@keys\fR is an list containing all the keys of the hash.
.PP
Example:
.PP
.Vb 2
\&  sub my_hash_element_cb {
\&     my ($scanner, $data_ref,$node,$element_name,@keys) = @_ ;
\&
\&     # custom code using $data_ref
\&
\&     # resume exploration
\&     map {$scanner\->scan_hash($data_ref,$node,$element_name,$_)} @keys ;
\&  }
.Ve
.SS "Node content callback"
.IX Subsection "Node content callback"
\&\f(CW\*(C`node_content_cb\*(C'\fR: This call-back is called foreach node (including
root node).
.PP
.Vb 1
\& ($scanner, $data_ref,$node,@element_list)
.Ve
.PP
\&\f(CW@element_list\fR contains all the element names of the node.
.PP
Example:
.PP
.Vb 2
\&  sub my_node_element_cb = { 
\&     my ($scanner, $data_ref,$node,@element) = @_ ;
\&
\&     # custom code using $data_ref
\&
\&     # resume exploration
\&     map {$scanner\->scan_element($data_ref, $node,$_)} @element ;
\&  }
.Ve
.SS "Node element callback"
.IX Subsection "Node element callback"
\&\f(CW\*(C`node_element_cb\*(C'\fR is called for each node contained within a node
(i.e not with root node). This node can be held by a plain element or
a hash element or a list element:
.PP
.Vb 1
\& ($scanner, $data_ref,$node,$element_name,$key, $contained_node)
.Ve
.PP
\&\f(CW$key\fR may be undef if \f(CW$contained_node\fR is not a part of a hash or
a list. \f(CW$element_name\fR and \f(CW$key\fR specifies the element name and
key of the the contained node you want to scan. (passed with
\&\f(CW$contained_node\fR) Note that \f(CW$contained_node\fR may be undef if
\&\f(CW\*(C`auto_vivify\*(C'\fR is 0.
.PP
Example:
.PP
.Vb 2
\&  sub my_node_content_cb {
\&    my ($scanner, $data_ref,$node,$element_name,$key, $contained_node) = @_;
\&
\&    # your custom code using $data_ref
\&
\&    # explore next node 
\&    $scanner\->scan_node($data_ref,$contained_node);
\&  }
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "scan_node ($data_r,$node)"
.IX Subsection "scan_node ($data_r,$node)"
Explore the node and call \f(CW\*(C`node_element_cb\*(C'\fR passing all element names.
.SS "scan_element($data_r,$node,$element_name)"
.IX Subsection "scan_element($data_r,$node,$element_name)"
Explore the element and call either \f(CW\*(C`hash_element_cb\*(C'\fR,
\&\f(CW\*(C`list_element_cb\*(C'\fR, \f(CW\*(C`node_content_cb\*(C'\fR or a leaf call-back (the leaf
call-back called depends on the Value object properties: enum, string,
integer and so on)
.SS "scan_hash ($data_r,$node,$element_name,$key)"
.IX Subsection "scan_hash ($data_r,$node,$element_name,$key)"
Explore the hash member (or hash value) and call either \f(CW\*(C`node_content_cb\*(C'\fR or
a leaf call-back.
.SS "scan_list ($data_r,$node,$element_name,$index)"
.IX Subsection "scan_list ($data_r,$node,$element_name,$index)"
Just like \f(CW\*(C`scan_hash\*(C'\fR: Explore the list member and call either
\&\f(CW\*(C`node_content_cb\*(C'\fR or a leaf call-back.
.ie n .SS "get_keys ($node, $element_name)"
.el .SS "get_keys ($node, \f(CW$element_name\fP)"
.IX Subsection "get_keys ($node, $element_name)"
Returns an list containing the sorted keys of a hash element or returns
an list containning (0.. last_index) of an list element.
.PP
Throws an exception if element is not an list or a hash element.
.SS "experience ( [ new_experience ] )"
.IX Subsection "experience ( [ new_experience ] )"
Set or query the experience level of the scanner
.SS "get_experience_ref ( )"
.IX Subsection "get_experience_ref ( )"
Get a \s-1SCALAR\s0 reference on experience. Use with care.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dominique Dumont, (ddumont at cpan dot org)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Config::Model,Config::Model::Node,Config::Model::Instance, 
Config::Model::HashId,
Config::Model::ListId,
Config::Model::CheckList,
Config::Model::Value
