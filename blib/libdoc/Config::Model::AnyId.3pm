.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Config::Model::AnyId 3pm"
.TH Config::Model::AnyId 3pm "2010-10-19" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Config::Model::AnyId \- Base class for hash or list element
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 8
\& $model \->create_config_class 
\&  (
\&   ...
\&   element 
\&   => [ 
\&       bounded_hash 
\&       => { type => \*(Aqhash\*(Aq,                 # hash id
\&            index_type  => \*(Aqinteger\*(Aq,
\&
\&            # hash boundaries
\&            min_index => 1, max_index => 123, max_nb => 2 ,
\&
\&            # specify cargo held by hash
\&            cargo => { type => \*(Aqleaf\*(Aq,
\&                       value_type => \*(Aqstring\*(Aq
\&                     },
\&          },
\&      bounded_list 
\&       => { type => \*(Aqlist\*(Aq,                 # list id
\&
\&            max_index => 123, 
\&            cargo => { type => \*(Aqleaf\*(Aq,
\&                       value_type => \*(Aqstring\*(Aq
\&                     },
\&          },
\&      hash_of_nodes 
\&      => { type => \*(Aqhash\*(Aq,                 # hash id
\&           index_type  => \*(Aqinteger\*(Aq,
\&           cargo => { type => \*(Aqnode\*(Aq,
\&                      config_class_name => \*(AqFoo\*(Aq
\&                    },
\&         },
\&      ]
\&  ) ;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class provides hash or list elements for a Config::Model::Node.
.PP
The hash index can either be en enumerated type, a boolean, an integer
or a string.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
AnyId object should not be created directly.
.SH "Hash or list model declaration"
.IX Header "Hash or list model declaration"
A hash or list element must be declared with the following parameters:
.IP "type" 4
.IX Item "type"
Mandatory element type. Must be \f(CW\*(C`hash\*(C'\fR or \f(CW\*(C`list\*(C'\fR to have a
collection element.  The actual element type must be specified by
\&\f(CW\*(C`cargo =\*(C'\fR type> (See \*(L"\s-1CAVEATS\s0\*(R").
.IP "index_type" 4
.IX Item "index_type"
Either \f(CW\*(C`integer\*(C'\fR or \f(CW\*(C`string\*(C'\fR. Mandatory for hash.
.IP "ordered" 4
.IX Item "ordered"
Whether to keep the order of the hash keys (default no). (a bit like
Tie::IxHash).  The hash keys are ordered along their creation. The
order can be modified with swap,
move_up or
move_down.
.IP "cargo" 4
.IX Item "cargo"
Hash ref specifying the cargo held by the hash of list. This has must
contain:
.RS 4
.IP "type" 8
.IX Item "type"
Can be \f(CW\*(C`node\*(C'\fR or \f(CW\*(C`leaf\*(C'\fR (default).
.IP "config_class_name" 8
.IX Item "config_class_name"
Specifies the type of configuration object held in the hash. Only
valid when \f(CW\*(C`cargo\*(C'\fR \f(CW\*(C`type\*(C'\fR is \f(CW\*(C`node\*(C'\fR.
.IP "<other>" 8
.IX Item "<other>"
Constructor arguments passed to the cargo object. See
Config::Model::Node when \f(CW\*(C`cargo\->type\*(C'\fR is \f(CW\*(C`node\*(C'\fR. See 
Config::Model::Value when \f(CW\*(C`cargo\->type\*(C'\fR is \f(CW\*(C`leaf\*(C'\fR.
.RE
.RS 4
.RE
.IP "min_index" 4
.IX Item "min_index"
Specify the minimum value (optional, only for hash and for integer index)
.IP "max_index" 4
.IX Item "max_index"
Specify the maximum value (optional, only for integer index)
.IP "max_nb" 4
.IX Item "max_nb"
Specify the maximum number of indexes. (hash only, optional, may also
be used with string index type)
.IP "default_keys" 4
.IX Item "default_keys"
When set, the default parameter (or set of parameters) are used as
default keys hashes and created automatically when the keys or exists
functions are used on an \fIempty\fR hash.
.Sp
You can use \f(CW\*(C`default_keys => \*(Aqfoo\*(Aq\*(C'\fR, 
or \f(CW\*(C`default_keys => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq]\*(C'\fR.
.IP "default_with_init" 4
.IX Item "default_with_init"
To perform special set-up on children nodes you can also use
.Sp
.Vb 2
\&   default_with_init =>  { \*(Aqfoo\*(Aq => \*(AqX=Av Y=Bv\*(Aq  ,
\&                           \*(Aqbar\*(Aq => \*(AqY=Av Z=Cv\*(Aq }
.Ve
.IP "follow_keys_from" 4
.IX Item "follow_keys_from"
Specifies that the keys of the hash follow the keys of another hash in
the configuration tree. In other words, the hash you're creating will
always have the same keys as the other hash.
.Sp
.Vb 1
\&   follow_keys_from => \*(Aq\- another_hash\*(Aq
.Ve
.IP "allow_keys" 4
.IX Item "allow_keys"
Specifies authorized keys:
.Sp
.Vb 1
\&  allow_keys => [\*(Aqfoo\*(Aq,\*(Aqbar\*(Aq,\*(Aqbaz\*(Aq]
.Ve
.IP "allow_keys_from" 4
.IX Item "allow_keys_from"
A bit like the \f(CW\*(C`follow_keys_from\*(C'\fR parameters. Except that the hash pointed to
by \f(CW\*(C`allow_keys_from\*(C'\fR specified the authorized keys for this hash.
.Sp
.Vb 1
\&  allow_keys_from => \*(Aq\- another_hash\*(Aq
.Ve
.IP "allow_keys_matching" 4
.IX Item "allow_keys_matching"
Keys must match the specified regular expression. For instance:
.Sp
.Vb 1
\&  allow_keys_matching => \*(Aq^foo\ed\ed$\*(Aq
.Ve
.IP "auto_create_keys" 4
.IX Item "auto_create_keys"
When set, the default parameter (or set of parameters) are used as
keys hashes and created automatically. (valid only for hash elements)
.Sp
Called with \f(CW\*(C`auto_create => \*(Aqfoo\*(Aq\*(C'\fR, or 
\&\f(CW\*(C`auto_create => [\*(Aqfoo\*(Aq, \*(Aqbar\*(Aq]\*(C'\fR.
.IP "warn_if_key_match" 4
.IX Item "warn_if_key_match"
Issue a warning if the key matches the specified regular expression
.IP "warn_unless_key_match" 4
.IX Item "warn_unless_key_match"
Issue a warning unless the key matches the specified regular expression
.IP "auto_create_ids" 4
.IX Item "auto_create_ids"
Specifies the number of elements to create automatically. E.g.  \f(CW\*(C`auto_create => 4\*(C'\fR will initialize the list with 4 undef elements.
(valid only for list elements)
.IP "warp" 4
.IX Item "warp"
See \*(L"Warp: dynamic value configuration\*(R" below.
.SH "Warp: dynamic value configuration"
.IX Header "Warp: dynamic value configuration"
The Warp functionality enables an HashId or
ListId object to change its default settings
(e.g. \f(CW\*(C`min_index\*(C'\fR, \f(CW\*(C`max_index\*(C'\fR or \f(CW\*(C`max_nb\*(C'\fR parameters) dynamically according to
the value of another \f(CW\*(C`Value\*(C'\fR object. (See
Config::Model::WarpedThing for explanation on warp mechanism)
.PP
For instance, with this model:
.PP
.Vb 10
\& $model \->create_config_class 
\&  (
\&   name => \*(AqRoot\*(Aq,
\&   \*(Aqelement\*(Aq
\&   => [
\&       macro => { type => \*(Aqleaf\*(Aq,
\&                  value_type => \*(Aqenum\*(Aq,
\&                  name       => \*(Aqmacro\*(Aq,
\&                  choice     => [qw/A B C/],
\&                },
\&       warped_hash => { type => \*(Aqhash\*(Aq,
\&                        index_type => \*(Aqinteger\*(Aq,
\&                        max_nb     => 3,
\&                        warp       => {
\&                                       follow => \*(Aq\- macro\*(Aq,
\&                                       rules => { A => { max_nb => 1 },
\&                                                  B => { max_nb => 2 }
\&                                                }
\&                                      },
\&                        cargo => { type => \*(Aqnode\*(Aq,
\&                                   config_class_name => \*(AqDummy\*(Aq
\&                                 }
\&                      },
\&     ]
\&  );
.Ve
.PP
Setting \f(CW\*(C`macro\*(C'\fR to \f(CW\*(C`A\*(C'\fR will mean that \f(CW\*(C`warped_hash\*(C'\fR can only accept
one instance of \f(CW\*(C`Dummy\*(C'\fR.
.PP
Setting \f(CW\*(C`macro\*(C'\fR to \f(CW\*(C`B\*(C'\fR will mean that \f(CW\*(C`warped_hash\*(C'\fR will accept two
instances of \f(CW\*(C`Dummy\*(C'\fR.
.PP
Like other warped class, a HashId or ListId can have multiple warp
masters (See \*(L"Warp follow argument\*(R" in Config::Model::WarpedThing:
.PP
.Vb 7
\&  warp => { follow => { m1 => \*(Aq\- macro1\*(Aq, 
\&                        m2 => \*(Aq\- macro2\*(Aq 
\&                      },
\&            rules  => [ \*(Aq$m1 eq "A" and $m2 eq "A2"\*(Aq => { max_nb => 1},
\&                        \*(Aq$m1 eq "A" and $m2 eq "B2"\*(Aq => { max_nb => 2}
\&                      ],
\&          }
.Ve
.SS "Warp and auto_create_ids or auto_create_keys"
.IX Subsection "Warp and auto_create_ids or auto_create_keys"
When a warp is applied with \f(CW\*(C`auto_create_keys\*(C'\fR or \f(CW\*(C`auto_create_ids\*(C'\fR
parameter, the auto_created items are created if they are not already
present. But this warp will never remove items that were previously
auto created.
.PP
For instance, if a tied hash is created with 
\&\f(CW\*(C`auto_create => [a,b,c]\*(C'\fR, the hash contains \f(CW\*(C`(a,b,c)\*(C'\fR.
.PP
Then if a warp is applied with \f(CW\*(C`auto_create => [c,d,e]\*(C'\fR, the hash
will contain \f(CW\*(C`(a,b,c,d,e)\*(C'\fR. The items created by the first
auto_create are not removed.
.SS "Warp and max_nb"
.IX Subsection "Warp and max_nb"
When a warp is applied, the items that do not fit the constraint
(e.g. min_index, max_index) are removed.
.PP
For the max_nb constraint, an exception will be raised if a warp 
leads to a nb of items greater than the max_nb constraint.
.SH "Introspection methods"
.IX Header "Introspection methods"
The following methods returns the current value stored in the Id
object (as declared in the model unless they were warped):
.IP "min_index" 4
.IX Item "min_index"
.PD 0
.IP "max_index" 4
.IX Item "max_index"
.IP "max_nb" 4
.IX Item "max_nb"
.IP "index_type" 4
.IX Item "index_type"
.IP "default_keys" 4
.IX Item "default_keys"
.IP "default_with_init" 4
.IX Item "default_with_init"
.IP "follow_keys_from" 4
.IX Item "follow_keys_from"
.IP "auto_create_ids" 4
.IX Item "auto_create_ids"
.IP "auto_create_keys" 4
.IX Item "auto_create_keys"
.IP "ordered" 4
.IX Item "ordered"
.IP "morph" 4
.IX Item "morph"
.IP "config_model" 4
.IX Item "config_model"
.PD
.SS "\fIget_cargo_type()\fP"
.IX Subsection "get_cargo_type()"
Returns the object type contained by the hash or list (i.e. returns
\&\f(CW\*(C`cargo \-> type\*(C'\fR).
.SS "get_cargo_info( < what > )"
.IX Subsection "get_cargo_info( < what > )"
Returns more info on the cargo contained by the hash or list. \f(CW\*(C`what\*(C'\fR
may be \f(CW\*(C`value_type\*(C'\fR or any other cargo info stored in the model. Will
return undef if the requested info was not provided in the model.
.SS "get_default_keys"
.IX Subsection "get_default_keys"
Returns a list (or a list ref) of the current default keys. These keys
can be set by the \f(CW\*(C`default_keys\*(C'\fR or \f(CW\*(C`default_with_init\*(C'\fR parameters
or by the other hash pointed by \f(CW\*(C`follow_keys_from\*(C'\fR parameter.
.SS "\fIname()\fP"
.IX Subsection "name()"
Returns the object name. The name finishes with ' id'.
.SS "\fIconfig_class_name()\fP"
.IX Subsection "config_class_name()"
Returns the config_class_name of collected elements. Valid only
for collection of nodes.
.PP
This method will return undef if \f(CW\*(C`cargo\*(C'\fR \f(CW\*(C`type\*(C'\fR is not \f(CW\*(C`node\*(C'\fR.
.SH "Informations management"
.IX Header "Informations management"
.ie n .SS "fetch_with_id ( index => $idx , [ check => 'no' ])"
.el .SS "fetch_with_id ( index => \f(CW$idx\fP , [ check => 'no' ])"
.IX Subsection "fetch_with_id ( index => $idx , [ check => 'no' ])"
Fetch the collected element held by the hash or list. Index check is 'yes' by default.
Can be called with one parameter: idx.
.SS "get( path,  [ custom | preset | standard | default ])"
.IX Subsection "get( path,  [ custom | preset | standard | default ])"
Get a value from a directory like path.
.SS "set( path, value )"
.IX Subsection "set( path, value )"
Set a value with a directory like path.
.SS "copy ( from_index, to_index )"
.IX Subsection "copy ( from_index, to_index )"
Deep copy an element within the hash or list. If the element contained
by the hash or list is a node, all configuration information is
copied from one node to another.
.SS "\fIfetch_all()\fP"
.IX Subsection "fetch_all()"
Returns an array containing all elements held by the hash or list.
.SS "fetch_all_values( mode => ..., check => ...)"
.IX Subsection "fetch_all_values( mode => ..., check => ...)"
Returns an array containing all defined values held by the hash or
list. (undefined values are simply discarded)
.PP
With \f(CW\*(C`mode\*(C'\fR parameter, this method will return either:
.IP "custom" 4
.IX Item "custom"
The value entered by the user
.IP "preset" 4
.IX Item "preset"
The value entered in preset mode
.IP "standard" 4
.IX Item "standard"
The value entered in preset mode or checked by default.
.IP "default" 4
.IX Item "default"
The default value (defined by the configuration model)
.SS "\fIget_all_indexes()\fP"
.IX Subsection "get_all_indexes()"
Returns an array containing all indexes of the hash or list. Hash keys
are sorted alphabetically, except for ordered hashed.
.SS "defined ( index )"
.IX Subsection "defined ( index )"
Returns true if the value held at \f(CW\*(C`index\*(C'\fR is defined.
.SS "exists ( index )"
.IX Subsection "exists ( index )"
Returns true if the value held at \f(CW\*(C`index\*(C'\fR exists (i.e the key exists
but the value may be undefined). This method may not make sense for
list element.
.SS "delete ( index )"
.IX Subsection "delete ( index )"
Delete the \f(CW\*(C`index\*(C'\fRed value
.SS "\fIclear()\fP"
.IX Subsection "clear()"
Delete all values (also delete underlying value or node objects).
.SS "\fIclear_values()\fP"
.IX Subsection "clear_values()"
Delete all values (without deleting underlying value objects).
.SS "warning_msg ( [index] )"
.IX Subsection "warning_msg ( [index] )"
Returns warnings concerning indexes of this hash. 
Without parameter, returns a hash ref or undef. With an index, return the warnings
concerning this index or undef.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dominique Dumont, ddumont [\s-1AT\s0] cpan [\s-1DOT\s0] org
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Config::Model,
Config::Model::Instance,
Config::Model::Node,
Config::Model::WarpedNode,
Config::Model::HashId,
Config::Model::ListId,
Config::Model::CheckList,
Config::Model::Value
